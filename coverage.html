
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ex0rcist/metflix/cmd/agent/main.go (0.0%)</option>
				
				<option value="file1">github.com/ex0rcist/metflix/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">github.com/ex0rcist/metflix/cmd/staticlint/main.go (0.0%)</option>
				
				<option value="file3">github.com/ex0rcist/metflix/docs/api/docs.go (100.0%)</option>
				
				<option value="file4">github.com/ex0rcist/metflix/internal/agent/agent.go (39.7%)</option>
				
				<option value="file5">github.com/ex0rcist/metflix/internal/agent/exporter/batch_exporter.go (61.4%)</option>
				
				<option value="file6">github.com/ex0rcist/metflix/internal/agent/exporter/exporter.go (100.0%)</option>
				
				<option value="file7">github.com/ex0rcist/metflix/internal/agent/exporter/limited_exporter.go (73.5%)</option>
				
				<option value="file8">github.com/ex0rcist/metflix/internal/agent/runtime.go (100.0%)</option>
				
				<option value="file9">github.com/ex0rcist/metflix/internal/agent/stats.go (92.9%)</option>
				
				<option value="file10">github.com/ex0rcist/metflix/internal/agent/system.go (83.3%)</option>
				
				<option value="file11">github.com/ex0rcist/metflix/internal/compression/compression.go (66.7%)</option>
				
				<option value="file12">github.com/ex0rcist/metflix/internal/compression/compressor.go (78.9%)</option>
				
				<option value="file13">github.com/ex0rcist/metflix/internal/compression/decompressor.go (96.0%)</option>
				
				<option value="file14">github.com/ex0rcist/metflix/internal/entities/address.go (100.0%)</option>
				
				<option value="file15">github.com/ex0rcist/metflix/internal/entities/errors.go (0.0%)</option>
				
				<option value="file16">github.com/ex0rcist/metflix/internal/entities/secret.go (0.0%)</option>
				
				<option value="file17">github.com/ex0rcist/metflix/internal/httpserver/converters.go (92.3%)</option>
				
				<option value="file18">github.com/ex0rcist/metflix/internal/httpserver/handlers.go (78.5%)</option>
				
				<option value="file19">github.com/ex0rcist/metflix/internal/httpserver/router.go (100.0%)</option>
				
				<option value="file20">github.com/ex0rcist/metflix/internal/httpserver/server.go (0.0%)</option>
				
				<option value="file21">github.com/ex0rcist/metflix/internal/logging/debug.go (0.0%)</option>
				
				<option value="file22">github.com/ex0rcist/metflix/internal/logging/error.go (0.0%)</option>
				
				<option value="file23">github.com/ex0rcist/metflix/internal/logging/fatal.go (0.0%)</option>
				
				<option value="file24">github.com/ex0rcist/metflix/internal/logging/info.go (0.0%)</option>
				
				<option value="file25">github.com/ex0rcist/metflix/internal/logging/logging.go (48.4%)</option>
				
				<option value="file26">github.com/ex0rcist/metflix/internal/logging/warn.go (0.0%)</option>
				
				<option value="file27">github.com/ex0rcist/metflix/internal/middleware/compression.go (96.8%)</option>
				
				<option value="file28">github.com/ex0rcist/metflix/internal/middleware/request_logger.go (26.7%)</option>
				
				<option value="file29">github.com/ex0rcist/metflix/internal/middleware/security.go (77.1%)</option>
				
				<option value="file30">github.com/ex0rcist/metflix/internal/profiler/profiler.go (31.6%)</option>
				
				<option value="file31">github.com/ex0rcist/metflix/internal/retrier/retrier.go (100.0%)</option>
				
				<option value="file32">github.com/ex0rcist/metflix/internal/server/profile_server.go (100.0%)</option>
				
				<option value="file33">github.com/ex0rcist/metflix/internal/server/server.go (50.0%)</option>
				
				<option value="file34">github.com/ex0rcist/metflix/internal/services/pinger.go (100.0%)</option>
				
				<option value="file35">github.com/ex0rcist/metflix/internal/services/signer.go (76.9%)</option>
				
				<option value="file36">github.com/ex0rcist/metflix/internal/storage/database.go (56.9%)</option>
				
				<option value="file37">github.com/ex0rcist/metflix/internal/storage/database_migrator.go (0.0%)</option>
				
				<option value="file38">github.com/ex0rcist/metflix/internal/storage/file.go (69.5%)</option>
				
				<option value="file39">github.com/ex0rcist/metflix/internal/storage/memory.go (96.8%)</option>
				
				<option value="file40">github.com/ex0rcist/metflix/internal/storage/record.go (95.7%)</option>
				
				<option value="file41">github.com/ex0rcist/metflix/internal/storage/service.go (88.5%)</option>
				
				<option value="file42">github.com/ex0rcist/metflix/internal/utils/http.go (100.0%)</option>
				
				<option value="file43">github.com/ex0rcist/metflix/internal/utils/request_id.go (100.0%)</option>
				
				<option value="file44">github.com/ex0rcist/metflix/internal/utils/time.go (100.0%)</option>
				
				<option value="file45">github.com/ex0rcist/metflix/internal/validators/validators.go (100.0%)</option>
				
				<option value="file46">github.com/ex0rcist/metflix/models/metrics_metric_exchange.go (0.0%)</option>
				
				<option value="file47">github.com/ex0rcist/metflix/pkg/metrics/metrics.go (0.0%)</option>
				
				<option value="file48">github.com/ex0rcist/metflix/pkg/metrics/types.go (33.3%)</option>
				
				<option value="file49">github.com/ex0rcist/metflix/pkg/noexit/analyzer.go (97.2%)</option>
				
				<option value="file50">github.com/ex0rcist/metflix/pkg/staticlint/staticlint.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/ex0rcist/metflix/internal/agent"
        "github.com/ex0rcist/metflix/internal/logging"
)

var (
        buildVersion = "N/A"
        buildDate    = "N/A"
        buildCommit  = "N/A"
)

func main() <span class="cov0" title="0">{
        logging.Setup()

        logging.LogInfoF("starting agent v%s [%s, #%s]...", buildVersion, buildDate, buildCommit)

        agnt, err := agent.New()
        if err != nil </span><span class="cov0" title="0">{
                logging.LogFatal(err)
        }</span>

        <span class="cov0" title="0">agnt.Run()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"

        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/internal/server"
)

var (
        buildVersion = "N/A"
        buildDate    = "N/A"
        buildCommit  = "N/A"
)

func main() <span class="cov0" title="0">{
        logging.Setup()
        fmt.Printf("Build version: %s\nBuild date: %s\nBuild commit: %s\n", buildVersion, buildDate, buildCommit)

        srv, err := server.New()
        if err != nil </span><span class="cov0" title="0">{
                logging.LogFatal(err)
        }</span>

        <span class="cov0" title="0">srv.Start()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import "github.com/ex0rcist/metflix/pkg/staticlint"

func main() <span class="cov0" title="0">{
        lint := staticlint.New()
        lint.Run()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package api Code generated by swaggo/swag. DO NOT EDIT
package api

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Evgeniy Shuvalov",
            "email": "evshuvalov@yandex.ru"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/": {
            "get": {
                "produces": [
                    "text/html"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "Yet another homepage",
                "operationId": "homepage",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/ping": {
            "get": {
                "tags": [
                    "Healthcheck"
                ],
                "summary": "Verify server up and running",
                "operationId": "health_info",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "501": {
                        "description": "Not Implemented",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/update": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "Push metric data as JSON",
                "operationId": "metrics_json_update",
                "parameters": [
                    {
                        "description": "Request parameters.",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/metrics.MetricExchange"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/metrics.MetricExchange"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/update/{type}/{name}/{value}": {
            "post": {
                "produces": [
                    "text/plain"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "Push metric data.",
                "operationId": "metrics_update",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Metrics type (e.g. ` + "`" + `counter` + "`" + `, ` + "`" + `gauge` + "`" + `).",
                        "name": "type",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Metrics name.",
                        "name": "name",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Metrics value, must be convertable to ` + "`" + `int64` + "`" + ` or ` + "`" + `float64` + "`" + `.",
                        "name": "value",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/updates": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "Push list of metrics data as JSON",
                "operationId": "metrics_json_update_list",
                "parameters": [
                    {
                        "description": "List of metrics to update.",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/metrics.MetricExchange"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/metrics.MetricExchange"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/value": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "Get metrics value as JSON",
                "operationId": "metrics_json_info",
                "parameters": [
                    {
                        "description": "Request parameters: ` + "`" + `id` + "`" + ` and ` + "`" + `type` + "`" + ` are required.",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/metrics.MetricExchange"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/metrics.MetricExchange"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/value/{type}/{name}": {
            "get": {
                "produces": [
                    "text/plain"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "Get metric's value as string",
                "operationId": "metrics_info",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Metrics type (e.g. ` + "`" + `counter` + "`" + `, ` + "`" + `gauge` + "`" + `).",
                        "name": "type",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Metrics name.",
                        "name": "name",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "metrics.MetricExchange": {
            "type": "object",
            "properties": {
                "delta": {
                    "type": "integer"
                },
                "id": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "value": {
                    "type": "number"
                }
            }
        }
    },
    "tags": [
        {
            "description": "\"Metrics API\"",
            "name": "Metrics"
        },
        {
            "description": "\"API to inspect service health state\"",
            "name": "Healthcheck"
        }
    ]
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Metrics collector API",
        Description:      "Service for storing metrics data.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov10" title="2">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package agent

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/caarlos0/env/v11"
        "github.com/ex0rcist/metflix/internal/agent/exporter"
        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/internal/services"
        "github.com/ex0rcist/metflix/internal/utils"
        "github.com/spf13/pflag"
)

// Metric collecting agent (mr. Bond?).
type Agent struct {
        Config   *Config
        Stats    *Stats
        Exporter exporter.Exporter

        wg sync.WaitGroup
}

// Agent config.
type Config struct {
        Address        entities.Address `env:"ADDRESS"`
        PollInterval   int              `env:"POLL_INTERVAL"`
        ReportInterval int              `env:"REPORT_INTERVAL"`
        RateLimit      int              `env:"RATE_LIMIT"`
        Secret         entities.Secret  `env:"KEY"`
}

// Constructor.
func New() (*Agent, error) <span class="cov8" title="1">{
        config := &amp;Config{
                Address:        "0.0.0.0:8080",
                PollInterval:   2,
                ReportInterval: 10,
                RateLimit:      -1,
        }

        err := parseConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">exporter, err := newMetricsExporter(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Agent{
                Config:   config,
                Stats:    NewStats(),
                Exporter: exporter,
        }, nil</span>
}

// Run agent.
func (a *Agent) Run() <span class="cov0" title="0">{
        logging.LogInfo(a.Config.String())
        logging.LogInfo("agent ready")

        ctx := context.Background()

        a.wg.Add(2)

        go a.startPolling(ctx)
        go a.startReporting()

        a.wg.Wait()
}</span>

func (a *Agent) startPolling(ctx context.Context) <span class="cov0" title="0">{
        defer a.wg.Done()

        for </span><span class="cov0" title="0">{
                err := a.Stats.Poll(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logging.LogError(err)
                }</span>

                <span class="cov0" title="0">time.Sleep(utils.IntToDuration(a.Config.PollInterval))</span>
        }
}

func (a *Agent) startReporting() <span class="cov0" title="0">{
        defer a.wg.Done()

        for </span><span class="cov0" title="0">{
                time.Sleep(utils.IntToDuration(a.Config.ReportInterval))

                a.reportStats()
        }</span>
}

func (a *Agent) reportStats() <span class="cov0" title="0">{
        logging.LogInfo("reporting stats ... ")

        // agent continues polling while report is in progress, take snapshot?
        snapshot := *a.Stats

        a.Exporter.
                Add("Alloc", snapshot.Runtime.Alloc).
                Add("BuckHashSys", snapshot.Runtime.BuckHashSys).
                Add("Frees", snapshot.Runtime.Frees).
                Add("GCCPUFraction", snapshot.Runtime.GCCPUFraction).
                Add("GCSys", snapshot.Runtime.GCSys).
                Add("HeapAlloc", snapshot.Runtime.HeapAlloc).
                Add("HeapIdle", snapshot.Runtime.HeapIdle).
                Add("HeapInuse", snapshot.Runtime.HeapInuse).
                Add("HeapObjects", snapshot.Runtime.HeapObjects).
                Add("HeapReleased", snapshot.Runtime.HeapReleased).
                Add("HeapSys", snapshot.Runtime.HeapSys).
                Add("LastGC", snapshot.Runtime.LastGC).
                Add("Lookups", snapshot.Runtime.Lookups).
                Add("MCacheInuse", snapshot.Runtime.MCacheInuse).
                Add("MCacheSys", snapshot.Runtime.MCacheSys).
                Add("MSpanInuse", snapshot.Runtime.MSpanInuse).
                Add("MSpanSys", snapshot.Runtime.MSpanSys).
                Add("Mallocs", snapshot.Runtime.Mallocs).
                Add("NextGC", snapshot.Runtime.NextGC).
                Add("NumForcedGC", snapshot.Runtime.NumForcedGC).
                Add("NumGC", snapshot.Runtime.NumGC).
                Add("OtherSys", snapshot.Runtime.OtherSys).
                Add("PauseTotalNs", snapshot.Runtime.PauseTotalNs).
                Add("StackInuse", snapshot.Runtime.StackInuse).
                Add("StackSys", snapshot.Runtime.StackSys).
                Add("Sys", snapshot.Runtime.Sys).
                Add("TotalAlloc", snapshot.Runtime.TotalAlloc)

        a.Exporter.
                Add("RandomValue", snapshot.RandomValue)

        a.Exporter.
                Add("PollCount", snapshot.PollCount)

        a.Exporter.
                Add("FreeMemory", snapshot.System.FreeMemory).
                Add("TotalMemory", snapshot.System.TotalMemory)

        for i, u := range snapshot.System.CPUutilization </span><span class="cov0" title="0">{
                a.Exporter.Add(fmt.Sprintf("CPUutilization%d", i+1), u)
        }</span>

        <span class="cov0" title="0">err := a.Exporter.Send()
        if err != nil </span><span class="cov0" title="0">{
                logging.LogErrorF("error sending metrics: %w", err)
        }</span>

        <span class="cov0" title="0">a.Exporter.Reset()

        // because metrics.Counter adds value to itself
        a.Stats.PollCount -= snapshot.PollCount</span>
}

// Stringer.
func (c Config) String() string <span class="cov0" title="0">{
        str := []string{
                fmt.Sprintf("address=%s", c.Address),
                fmt.Sprintf("poll-interval=%v", c.PollInterval),
                fmt.Sprintf("report-interval=%v", c.ReportInterval),
                fmt.Sprintf("rate-limit=%v", c.RateLimit),
        }

        if len(c.Secret) &gt; 0 </span><span class="cov0" title="0">{
                str = append(str, fmt.Sprintf("secret=%v", c.Secret))
        }</span>

        <span class="cov0" title="0">return "agent config: " + strings.Join(str, "; ")</span>
}

func detectExporterKind(c *Config) string <span class="cov8" title="1">{
        var ek string

        switch </span>{
        case c.RateLimit &gt; 0:<span class="cov0" title="0">
                ek = exporter.KindLimited</span>
        default:<span class="cov8" title="1">
                ek = exporter.KindBatch</span>
        }

        <span class="cov8" title="1">return ek</span>
}

func newMetricsExporter(config *Config) (exporter.Exporter, error) <span class="cov8" title="1">{
        var exp exporter.Exporter
        var signer services.Signer
        var err error

        if len(config.Secret) &gt; 0 </span><span class="cov0" title="0">{
                signer = services.NewSignerService(config.Secret)
        }</span>

        <span class="cov8" title="1">exporterKind := detectExporterKind(config)

        switch exporterKind </span>{
        case exporter.KindLimited:<span class="cov0" title="0">
                exp = exporter.NewLimitedExporter(&amp;config.Address, signer, config.RateLimit)</span>
        case exporter.KindBatch:<span class="cov8" title="1">
                exp = exporter.NewBatchExporter(&amp;config.Address, signer)</span>
        default:<span class="cov0" title="0">
                exp, err = nil, fmt.Errorf("unknown exporter type")</span>
        }

        <span class="cov8" title="1">return exp, err</span>
}

func parseConfig(config *Config) error <span class="cov8" title="1">{
        address := config.Address
        pflag.VarP(&amp;address, "address", "a", "address:port for HTTP API requests")

        secret := config.Secret
        pflag.VarP(&amp;secret, "secret", "k", "a key to sign outgoing data")

        pflag.IntVarP(&amp;config.PollInterval, "poll-interval", "p", config.PollInterval, "interval (s) for polling stats")
        pflag.IntVarP(&amp;config.ReportInterval, "report-interval", "r", config.ReportInterval, "interval (s) for polling stats")
        pflag.IntVarP(&amp;config.RateLimit, "rate-limit", "l", config.RateLimit, "number of max simultaneous requests to server")

        pflag.Parse()

        // because VarP gets non-pointer value, set it manually
        pflag.Visit(func(f *pflag.Flag) </span><span class="cov0" title="0">{
                switch f.Name </span>{
                case "address":<span class="cov0" title="0">
                        config.Address = address</span>
                case "secret":<span class="cov0" title="0">
                        config.Secret = secret</span>
                }
        })

        <span class="cov8" title="1">if err := env.Parse(config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package exporter

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/ex0rcist/metflix/internal/compression"
        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/internal/retrier"
        "github.com/ex0rcist/metflix/internal/services"
        "github.com/ex0rcist/metflix/internal/utils"
        "github.com/ex0rcist/metflix/pkg/metrics"
)

var _ Exporter = (*BatchExporter)(nil)

// Batch exporter to optimize requests count.
type BatchExporter struct {
        baseURL *entities.Address
        client  *http.Client
        signer  services.Signer

        buffer []metrics.MetricExchange
        err    error
}

// Constructor.
func NewBatchExporter(baseURL *entities.Address, signer services.Signer) *BatchExporter <span class="cov8" title="1">{
        client := &amp;http.Client{
                Timeout: 2 * time.Second,
        }

        return &amp;BatchExporter{
                baseURL: baseURL,
                client:  client,
                signer:  signer,
        }
}</span>

// Add a metric to batch.
func (e *BatchExporter) Add(name string, value metrics.Metric) Exporter <span class="cov8" title="1">{
        if e.err != nil </span><span class="cov0" title="0">{
                return e
        }</span>

        <span class="cov8" title="1">var mex metrics.MetricExchange
        switch value.Kind() </span>{
        case metrics.KindCounter:<span class="cov8" title="1">
                mex = metrics.NewUpdateCounterMex(name, value.(metrics.Counter))</span>

        case metrics.KindGauge:<span class="cov0" title="0">
                mex = metrics.NewUpdateGaugeMex(name, value.(metrics.Gauge))</span>

        default:<span class="cov0" title="0">
                e.err = entities.ErrMetricUnknown
                return e</span>
        }

        <span class="cov8" title="1">e.buffer = append(e.buffer, mex)

        return e</span>
}

// Send batch.
func (e *BatchExporter) Send() error <span class="cov8" title="1">{
        if e.err != nil </span><span class="cov0" title="0">{
                return e.err
        }</span>

        <span class="cov8" title="1">if len(e.buffer) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot send empty buffer")
        }</span>

        <span class="cov8" title="1">delays := []time.Duration{1 * time.Second, 3 * time.Second, 5 * time.Second}

        err := retrier.New(
                func() error </span><span class="cov8" title="1">{ return e.doSend() }</span>,
                func(err error) bool <span class="cov0" title="0">{
                        _, ok := err.(entities.RetriableError)
                        return ok
                }</span>,
                retrier.WithDelays(delays),
        ).Run()

        <span class="cov8" title="1">e.Reset()

        return err</span>
}

// Reset batch.
func (e *BatchExporter) Reset() <span class="cov8" title="1">{
        e.buffer = make([]metrics.MetricExchange, 0)
        e.err = nil
}</span>

// Get error if any.
func (e *BatchExporter) Error() error <span class="cov0" title="0">{
        if e.err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("metrics export failed: %w", e.err)</span>
}

func (e *BatchExporter) doSend() error <span class="cov8" title="1">{
        requestID := utils.GenerateRequestID()
        ctx := setupLoggerCtx(requestID)

        body, err := json.Marshal(e.buffer)
        if err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error during marshaling", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">payload, err := compression.Pack(body)
        if err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error during compression", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">url := "http://" + e.baseURL.String() + "/updates"
        req, err := http.NewRequest(http.MethodPost, url, payload)
        if err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "httpRequest error", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Content-Encoding", "gzip")
        req.Header.Set("X-Request-Id", requestID)

        if e.signer != nil </span><span class="cov8" title="1">{
                signature, signErr := e.signer.CalculateSignature(payload.Bytes())
                if signErr != nil </span><span class="cov0" title="0">{
                        logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error during signing", signErr.Error())
                        return signErr
                }</span>

                <span class="cov8" title="1">req.Header.Set("HashSHA256", signature)</span>
        }

        <span class="cov8" title="1">logRequest(ctx, url, req.Header, body)

        resp, err := e.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error making http request", err.Error())
                return entities.RetriableError{Err: err, RetryAfter: 10 * time.Second}
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        logging.LogError(closeErr)
                }</span>
        }()

        <span class="cov8" title="1">respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error reading response body", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">logResponse(ctx, resp, respBody)

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                formatedBody := strings.ReplaceAll(string(respBody), "\n", "")
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error reporting stats", resp.Status, formatedBody)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package exporter

import (
        "context"
        "fmt"
        "net/http"

        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/internal/utils"
        "github.com/ex0rcist/metflix/pkg/metrics"

        "github.com/rs/zerolog/log"
)

// Kinds of exporter
const (
        KindBatch   = "batch"
        KindLimited = "limited"
)

// Exporter interface.
type Exporter interface {
        Add(name string, value metrics.Metric) Exporter
        Send() error
        Error() error
        Reset()
}

func setupLoggerCtx(requestID string) context.Context <span class="cov10" title="3">{
        // empty context for now
        ctx := context.Background()

        // setup logger with rid attached
        logger := log.Logger.With().Ctx(ctx).Str("rid", requestID).Logger()

        // return context for logging
        return logger.WithContext(ctx)
}</span>

func logRequest(ctx context.Context, url string, headers http.Header, body []byte) <span class="cov10" title="3">{
        logging.LogInfoCtx(ctx, "sending request to: "+url)
        logging.LogDebugCtx(ctx, fmt.Sprintf("request: headers=%s; body=%s", utils.HeadersToStr(headers), string(body)))
}</span>

func logResponse(ctx context.Context, resp *http.Response, respBody []byte) <span class="cov6" title="2">{
        logging.LogDebugCtx(ctx, fmt.Sprintf("response: %v; headers=%s; body=%s", resp.Status, utils.HeadersToStr(resp.Header), respBody))
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package exporter

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/ex0rcist/metflix/internal/compression"
        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/internal/retrier"
        "github.com/ex0rcist/metflix/internal/services"
        "github.com/ex0rcist/metflix/internal/utils"
        "github.com/ex0rcist/metflix/pkg/metrics"
)

var _ Exporter = (*LimitedExporter)(nil)

// An exporter to send metrics one-by-one in parallel.
type LimitedExporter struct {
        baseURL *entities.Address
        client  *http.Client
        signer  services.Signer

        buffer []metrics.MetricExchange
        jobs   chan metrics.MetricExchange
        err    error
}

// Constructor.
func NewLimitedExporter(baseURL *entities.Address, signer services.Signer, numWorkers int) *LimitedExporter <span class="cov8" title="7">{
        client := &amp;http.Client{
                Timeout: 2 * time.Second,
        }

        exporter := &amp;LimitedExporter{
                baseURL: baseURL,
                client:  client,
                signer:  signer,
                jobs:    make(chan metrics.MetricExchange, 30),
        }

        exporter.spawnWorkers(numWorkers)

        return exporter
}</span>

// Add metric to buffer.
func (e *LimitedExporter) Add(name string, value metrics.Metric) Exporter <span class="cov6" title="4">{
        if e.err != nil </span><span class="cov0" title="0">{
                return e
        }</span>

        <span class="cov6" title="4">var mex metrics.MetricExchange
        switch value.Kind() </span>{
        case metrics.KindCounter:<span class="cov6" title="4">
                mex = metrics.NewUpdateCounterMex(name, value.(metrics.Counter))</span>

        case metrics.KindGauge:<span class="cov0" title="0">
                mex = metrics.NewUpdateGaugeMex(name, value.(metrics.Gauge))</span>

        default:<span class="cov0" title="0">
                logging.LogError(entities.ErrMetricReport, "unknown metric")

                e.err = entities.ErrMetricUnknown
                return e</span>
        }

        <span class="cov6" title="4">e.buffer = append(e.buffer, mex)

        return e</span>
}

// Send buffer out.
func (e *LimitedExporter) Send() error <span class="cov5" title="3">{
        if e.err != nil </span><span class="cov0" title="0">{
                return e.err
        }</span>

        <span class="cov5" title="3">if len(e.buffer) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot send empty buffer")
        }</span>

        <span class="cov3" title="2">logging.LogDebugF("sending %d jobs to channel", len(e.buffer))

        for _, mex := range e.buffer </span><span class="cov3" title="2">{
                e.jobs &lt;- mex
        }</span>

        <span class="cov3" title="2">e.Reset()

        return nil</span>
}

// Reset buffer.
func (e *LimitedExporter) Reset() <span class="cov5" title="3">{
        e.buffer = make([]metrics.MetricExchange, 0)
        e.err = nil
}</span>

// Get error if any.
func (e *LimitedExporter) Error() error <span class="cov1" title="1">{
        if e.err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">return fmt.Errorf("metrics export failed: %w", e.err)</span>
}

func (e *LimitedExporter) spawnWorkers(numWorkers int) <span class="cov8" title="7">{
        for w := 1; w &lt;= numWorkers; w++ </span><span class="cov10" title="11">{
                go e.worker(w)
        }</span>
}

func (e *LimitedExporter) worker(id int) <span class="cov10" title="11">{
        delays := []time.Duration{1 * time.Second, 3 * time.Second, 5 * time.Second}

        for mex := range e.jobs </span><span class="cov3" title="2">{
                logging.LogDebugF("worker #%d started job", id)

                err := retrier.New(
                        func() error </span><span class="cov3" title="2">{ return e.doSend(mex) }</span>,
                        func(err error) bool <span class="cov1" title="1">{
                                _, ok := err.(entities.RetriableError)
                                return ok
                        }</span>,
                        retrier.WithDelays(delays),
                ).Run()

                <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                        logging.LogError(err, "error during async working")
                }</span>

                <span class="cov1" title="1">logging.LogDebugF("worker #%d ended job", id)</span>
        }
}

func (e *LimitedExporter) doSend(mex metrics.MetricExchange) error <span class="cov3" title="2">{
        requestID := utils.GenerateRequestID()
        ctx := setupLoggerCtx(requestID)

        body, err := json.Marshal(mex)
        if err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error during marshaling", err.Error())
                return err
        }</span>

        <span class="cov3" title="2">payload, err := compression.Pack(body)
        if err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error during compression", err.Error())
                return err
        }</span>

        <span class="cov3" title="2">url := "http://" + e.baseURL.String() + "/update"

        req, err := http.NewRequest(http.MethodPost, url, payload)
        if err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "httpRequest error", err.Error())
                return err
        }</span>

        <span class="cov3" title="2">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Content-Encoding", "gzip")
        req.Header.Set("X-Request-Id", requestID)

        if e.signer != nil </span><span class="cov3" title="2">{
                signature, signErr := e.signer.CalculateSignature(payload.Bytes())
                if signErr != nil </span><span class="cov0" title="0">{
                        logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error during signing", signErr.Error())
                        return signErr
                }</span>

                <span class="cov3" title="2">req.Header.Set("HashSHA256", signature)</span>
        }

        <span class="cov3" title="2">logRequest(ctx, url, req.Header, body)

        resp, err := e.client.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error making http request", err.Error())
                return entities.RetriableError{Err: err, RetryAfter: 10 * time.Second}
        }</span>

        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        logging.LogError(closeErr)
                }</span>
        }()

        <span class="cov1" title="1">respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error reading response body", err.Error())
                return err
        }</span>

        <span class="cov1" title="1">logResponse(ctx, resp, respBody)

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                formatedBody := strings.ReplaceAll(string(respBody), "\n", "")
                logging.LogErrorCtx(ctx, entities.ErrMetricReport, "error reporting stats", resp.Status, formatedBody)
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package agent

import (
        "runtime"

        "github.com/ex0rcist/metflix/pkg/metrics"
)

// Runtime stats to be collected.
type RuntimeStats struct {
        Alloc         metrics.Gauge
        BuckHashSys   metrics.Gauge
        Frees         metrics.Gauge
        GCCPUFraction metrics.Gauge
        GCSys         metrics.Gauge
        HeapAlloc     metrics.Gauge
        HeapIdle      metrics.Gauge
        HeapInuse     metrics.Gauge
        HeapObjects   metrics.Gauge
        HeapReleased  metrics.Gauge
        HeapSys       metrics.Gauge
        LastGC        metrics.Gauge
        Lookups       metrics.Gauge
        MCacheInuse   metrics.Gauge
        MCacheSys     metrics.Gauge
        MSpanInuse    metrics.Gauge
        MSpanSys      metrics.Gauge
        Mallocs       metrics.Gauge
        NextGC        metrics.Gauge
        NumForcedGC   metrics.Gauge
        NumGC         metrics.Gauge
        OtherSys      metrics.Gauge
        PauseTotalNs  metrics.Gauge
        StackInuse    metrics.Gauge
        StackSys      metrics.Gauge
        Sys           metrics.Gauge
        TotalAlloc    metrics.Gauge
}

// Poll and collect stats.
func (m *RuntimeStats) Poll() <span class="cov10" title="5">{
        stats := runtime.MemStats{}
        runtime.ReadMemStats(&amp;stats)

        m.Alloc = metrics.Gauge(stats.Alloc)
        m.BuckHashSys = metrics.Gauge(stats.BuckHashSys)
        m.Frees = metrics.Gauge(stats.Frees)
        m.GCCPUFraction = metrics.Gauge(stats.GCCPUFraction)
        m.GCSys = metrics.Gauge(stats.GCSys)
        m.HeapAlloc = metrics.Gauge(stats.HeapAlloc)
        m.HeapIdle = metrics.Gauge(stats.HeapIdle)
        m.HeapInuse = metrics.Gauge(stats.HeapInuse)
        m.HeapObjects = metrics.Gauge(stats.HeapObjects)
        m.HeapReleased = metrics.Gauge(stats.HeapReleased)
        m.HeapSys = metrics.Gauge(stats.HeapSys)
        m.LastGC = metrics.Gauge(stats.LastGC)
        m.Lookups = metrics.Gauge(stats.Lookups)
        m.MCacheInuse = metrics.Gauge(stats.MCacheInuse)
        m.MCacheSys = metrics.Gauge(stats.MCacheSys)
        m.MSpanInuse = metrics.Gauge(stats.MSpanInuse)
        m.MSpanSys = metrics.Gauge(stats.MSpanSys)
        m.Mallocs = metrics.Gauge(stats.Mallocs)
        m.NextGC = metrics.Gauge(stats.NextGC)
        m.NumForcedGC = metrics.Gauge(stats.NumForcedGC)
        m.NumGC = metrics.Gauge(stats.NumGC)
        m.OtherSys = metrics.Gauge(stats.OtherSys)
        m.PauseTotalNs = metrics.Gauge(stats.PauseTotalNs)
        m.StackInuse = metrics.Gauge(stats.StackInuse)
        m.StackSys = metrics.Gauge(stats.StackSys)
        m.Sys = metrics.Gauge(stats.Sys)
        m.TotalAlloc = metrics.Gauge(stats.TotalAlloc)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package agent

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/pkg/metrics"
        "golang.org/x/sync/errgroup"
)

// All stats to be collected.
type Stats struct {
        System      SystemStats
        Runtime     RuntimeStats
        PollCount   metrics.Counter
        RandomValue metrics.Gauge

        generator *rand.Rand
}

// Constructor.
func NewStats() *Stats <span class="cov6" title="2">{
        r := rand.New(rand.NewSource(time.Now().UnixNano()))
        return &amp;Stats{generator: r}
}</span>

// Poll stats.
func (m *Stats) Poll(ctx context.Context) error <span class="cov10" title="3">{
        logging.LogDebug("polling stats ... ")

        m.PollCount++
        m.RandomValue = metrics.Gauge(m.generator.Float64())

        g, _ := errgroup.WithContext(ctx)

        g.Go(func() error </span><span class="cov10" title="3">{
                m.Runtime.Poll()
                return nil
        }</span>)

        <span class="cov10" title="3">g.Go(func() error </span><span class="cov10" title="3">{
                return m.System.Poll(ctx)
        }</span>)

        <span class="cov10" title="3">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to gather metrics: %w", err)
        }</span>

        <span class="cov10" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package agent

import (
        "context"
        "fmt"

        "github.com/ex0rcist/metflix/pkg/metrics"
        "github.com/shirou/gopsutil/cpu"
        "github.com/shirou/gopsutil/v4/mem"
)

// System stats to be reported.
type SystemStats struct {
        TotalMemory metrics.Gauge
        FreeMemory  metrics.Gauge

        CPUutilization []metrics.Gauge
}

// Poll stats and report.
func (s *SystemStats) Poll(ctx context.Context) error <span class="cov4" title="3">{
        vMem, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mem.VirtualMemory: %w", err)
        }</span>

        <span class="cov4" title="3">s.TotalMemory = metrics.Gauge(vMem.Total)
        s.FreeMemory = metrics.Gauge(vMem.Free)

        utilisation, err := cpu.PercentWithContext(ctx, 0, true)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cpu.PercentWithContext: %w", err)
        }</span>

        <span class="cov4" title="3">s.CPUutilization = []metrics.Gauge{}
        for _, u := range utilisation </span><span class="cov10" title="24">{
                s.CPUutilization = append(s.CPUutilization, metrics.Gauge(u))
        }</span>

        <span class="cov4" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package compression

import (
        "bytes"
        "fmt"

        "github.com/klauspost/compress/gzip"
)

// Pack []byte with gzip.
func Pack(data []byte) (*bytes.Buffer, error) <span class="cov8" title="1">{
        bb := new(bytes.Buffer)

        encoder, err := gzip.NewWriterLevel(bb, gzip.BestSpeed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed init compress writer: %v", err)
        }</span>

        <span class="cov8" title="1">if _, err = encoder.Write(data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed write data to compress temporary buffer: %v", err)
        }</span>

        <span class="cov8" title="1">if err = encoder.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed compress data: %v", err)
        }</span>

        <span class="cov8" title="1">return bb, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package compression

import (
        "context"
        "net/http"

        "github.com/klauspost/compress/gzip"

        "github.com/ex0rcist/metflix/internal/logging"
)

// Struct to handle compression.
type Compressor struct {
        http.ResponseWriter

        context          context.Context
        encoder          *gzip.Writer
        supportedContent map[string]struct{}
}

// Constructor.
func NewCompressor(w http.ResponseWriter, ctx context.Context) *Compressor <span class="cov10" title="3">{
        supportedContent := map[string]struct{}{
                "application/json": {}, // {} uses no memory
                "text/html":        {},
        }

        return &amp;Compressor{
                ResponseWriter:   w,
                context:          ctx,
                supportedContent: supportedContent,
        }
}</span>

// Write body to response.
func (c *Compressor) Write(resp []byte) (int, error) <span class="cov10" title="3">{
        contentType := c.Header().Get("Content-Type")

        if _, ok := c.supportedContent[contentType]; !ok </span><span class="cov1" title="1">{
                logging.LogDebugCtx(c.context, "compression not supported for "+contentType)
                return c.ResponseWriter.Write(resp)
        }</span>

        <span class="cov6" title="2">if c.encoder == nil </span><span class="cov6" title="2">{
                encoder, err := gzip.NewWriterLevel(c.ResponseWriter, gzip.BestSpeed)
                if err != nil </span><span class="cov0" title="0">{
                        logging.LogErrorCtx(c.context, err)
                        return c.ResponseWriter.Write(resp)
                }</span>
                <span class="cov6" title="2">c.encoder = encoder</span>
        }

        <span class="cov6" title="2">c.Header().Set("Content-Encoding", "gzip")

        return c.encoder.Write(resp)</span>
}

// Close encoder.
func (c *Compressor) Close() <span class="cov6" title="2">{
        if c.encoder == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="2">if err := c.encoder.Close(); err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(c.context, err, "error closing compressor encoder", err.Error())
        }</span>

        <span class="cov6" title="2">c.encoder = nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package compression

import (
        "context"
        "net/http"

        "github.com/klauspost/compress/gzip"

        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/logging"
)

// Struct to handle encoded requests.
type Decompressor struct {
        request            *http.Request
        reader             *gzip.Reader
        context            context.Context
        supportedEncodings map[string]struct{}
}

// Constructor.
func NewDecompressor(req *http.Request, ctx context.Context) *Decompressor <span class="cov10" title="5">{
        supportedEncodings := map[string]struct{}{
                "gzip": {}, // {} uses no memory
        }

        return &amp;Decompressor{
                request:            req,
                context:            ctx,
                supportedEncodings: supportedEncodings,
        }
}</span>

// Decompress incoming request.
func (d *Decompressor) Decompress() error <span class="cov10" title="5">{
        encoding := d.request.Header.Get("Content-Encoding")

        if len(encoding) == 0 </span><span class="cov1" title="1">{
                logging.LogDebugCtx(d.context, "no encoding provided")
                return nil
        }</span>

        <span class="cov8" title="4">logging.LogDebugCtx(d.context, "got request compressed with "+encoding)

        if _, ok := d.supportedEncodings[encoding]; !ok </span><span class="cov1" title="1">{
                err := entities.ErrEncodingUnsupported
                logging.LogErrorCtx(d.context, err, "decoding not supported for "+encoding)

                return err
        }</span>

        <span class="cov7" title="3">if d.reader == nil </span><span class="cov7" title="3">{
                reader, err := gzip.NewReader(d.request.Body)
                if err != nil </span><span class="cov1" title="1">{
                        err := entities.ErrEncodingInternal
                        logging.LogErrorCtx(d.context, err, "failed to create gzip reader: "+err.Error())

                        return err
                }</span>

                <span class="cov4" title="2">d.reader = reader</span>
        }

        <span class="cov4" title="2">d.request.Body = d.reader

        return nil</span>
}

// Close reader.
func (d *Decompressor) Close() <span class="cov7" title="3">{
        if d.reader == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov4" title="2">if err := d.reader.Close(); err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(d.context, err, "error closing decompressor reader", err.Error())
        }</span>

        <span class="cov4" title="2">d.reader = nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package entities

import (
        "fmt"
        "strconv"
        "strings"
)

// https://github.com/spf13/pflag/blob/master/README.md#usage
// must comply with https://pkg.go.dev/github.com/spf13/pflag@v1.0.5#Value.
type Address string

// Stringer.
func (a Address) String() string <span class="cov5" title="3">{
        return string(a)
}</span>

// Set value.
func (a *Address) Set(src string) error <span class="cov10" title="9">{
        chunks := strings.Split(src, ":")
        if len(chunks) != 2 </span><span class="cov7" title="5">{
                return fmt.Errorf("set address failed: %w", ErrBadAddressFormat)
        }</span>

        <span class="cov6" title="4">port := chunks[1]

        if _, err := strconv.Atoi(port); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("set address failed: %w", err)
        }</span>

        <span class="cov5" title="3">*a = Address(src)

        return nil</span>
}

// Return string for correct type conversion.
func (a Address) Type() string <span class="cov1" title="1">{
        return "string"
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package entities

import (
        "errors"
        "fmt"
        "time"
)

// Error types
var (
        ErrBadAddressFormat = errors.New("bad net address format")

        ErrRecordNotFound     = errors.New("metric not found")
        ErrMetricUnknown      = errors.New("unknown metric type")
        ErrMetricReport       = errors.New("metric report error")
        ErrMetricMissingName  = errors.New("metric name is missing")
        ErrMetricInvalidName  = errors.New("metric name contains invalid characters")
        ErrMetricLongName     = errors.New("metric name is too long")
        ErrMetricMissingValue = errors.New("metric value is missing")
        ErrMetricInvalidValue = errors.New("metric value is invalid")

        ErrStoragePush       = errors.New("failed to push record")
        ErrStorageFetch      = errors.New("failed to get record")
        ErrStorageUnpingable = errors.New("healthcheck is not supported")

        ErrEncodingInternal    = errors.New("internal encoding error")
        ErrEncodingUnsupported = errors.New("requsted encoding is not supported")

        ErrNoSignature = errors.New("no signature provided")

        ErrUnexpected = errors.New("unexpected error")
)

// Constructor wrapper.
func NewStackError(err error) error <span class="cov0" title="0">{
        return errors.New(err.Error())
}</span>

var _ error = (*RetriableError)(nil)

// Error to handle retries.
type RetriableError struct {
        Err        error
        RetryAfter time.Duration
}

// Return readable representation.
func (e RetriableError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s (retry after %v)", e.Err.Error(), e.RetryAfter)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package entities

import (
        "strings"

        "github.com/rs/zerolog/log"
)

// Entity to hide secrets in logs.
type Secret string

// Set value.
func (s *Secret) Set(src string) error <span class="cov0" title="0">{
        if len([]byte(src)) &lt; 32 </span><span class="cov0" title="0">{
                log.Warn().Msg("secret is too short")
        }</span>

        <span class="cov0" title="0">*s = Secret(src)

        return nil</span>
}

// Return a string for correct type conversion.
func (s Secret) Type() string <span class="cov0" title="0">{
        return "string"
}</span>

// Stringer.
func (s Secret) String() string <span class="cov0" title="0">{
        if len(s) &lt;= 2 </span><span class="cov0" title="0">{
                return string(s)
        }</span>

        <span class="cov0" title="0">masked := strings.Repeat("*", len(s)-2)
        return string(s[0]) + masked + string(s[len(s)-1])</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package httpserver

import (
        "fmt"

        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/storage"
        "github.com/ex0rcist/metflix/internal/validators"
        "github.com/ex0rcist/metflix/pkg/metrics"
)

// Convert from JSON-struct to storage.Record.
func toRecord(mex *metrics.MetricExchange) (storage.Record, error) <span class="cov10" title="20">{
        var record storage.Record

        if err := validators.ValidateMetric(mex.ID, mex.MType); err != nil </span><span class="cov7" title="8">{
                return record, err
        }</span>

        <span class="cov8" title="12">switch mex.MType </span>{
        case metrics.KindCounter:<span class="cov6" title="7">
                if mex.Delta == nil </span><span class="cov1" title="1">{
                        return record, entities.ErrMetricMissingValue
                }</span>

                <span class="cov6" title="6">record = storage.Record{Name: mex.ID, Value: *mex.Delta}</span>
        case metrics.KindGauge:<span class="cov5" title="5">
                if mex.Value == nil </span><span class="cov1" title="1">{
                        return record, entities.ErrMetricMissingValue
                }</span>

                <span class="cov5" title="4">record = storage.Record{Name: mex.ID, Value: *mex.Value}</span>
        default:<span class="cov0" title="0">
                return record, entities.ErrMetricUnknown</span>
        }

        <span class="cov7" title="10">return record, nil</span>
}

func toMetricExchange(record storage.Record) (*metrics.MetricExchange, error) <span class="cov6" title="6">{
        req := &amp;metrics.MetricExchange{ID: record.Name, MType: record.Value.Kind()}

        switch record.Value.Kind() </span>{
        case metrics.KindCounter:<span class="cov4" title="3">
                delta, _ := record.Value.(metrics.Counter)
                req.Delta = &amp;delta</span>

        case metrics.KindGauge:<span class="cov4" title="3">
                value, _ := record.Value.(metrics.Gauge)
                req.Value = &amp;value</span>
        }

        <span class="cov6" title="6">return req, nil</span>
}

func toMetricExchangeList(records []storage.Record) ([]*metrics.MetricExchange, error) <span class="cov1" title="1">{
        result := make([]*metrics.MetricExchange, len(records))

        for i, record := range records </span><span class="cov3" title="2">{
                req, err := toMetricExchange(record)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert record to MetricExchange: %w", err)
                }</span>

                <span class="cov3" title="2">result[i] = req</span>
        }

        <span class="cov1" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package httpserver

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"

        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/internal/profiler"
        "github.com/ex0rcist/metflix/internal/services"
        "github.com/ex0rcist/metflix/internal/storage"
        "github.com/ex0rcist/metflix/internal/validators"
        "github.com/ex0rcist/metflix/pkg/metrics"
)

// Resource to handle routes.
type MetricResource struct {
        storageService storage.StorageService
}

// Constructor.
func NewMetricResource(storageService storage.StorageService) MetricResource <span class="cov10" title="40">{
        return MetricResource{
                storageService: storageService,
        }
}</span>

func writeErrorResponse(ctx context.Context, w http.ResponseWriter, code int, err error) <span class="cov8" title="26">{
        logging.LogErrorCtx(ctx, err)

        w.WriteHeader(code) // only header for now
}</span>

// Homepage godoc
// @Tags Metrics
// @Router / [get]
// @Summary Yet another homepage
// @ID homepage
// @Produce text/html
// @Success 200 {string} string
// @Failure 500 {string} string http.StatusInternalServerError
func (r MetricResource) Homepage(rw http.ResponseWriter, req *http.Request) <span class="cov2" title="2">{
        ctx := req.Context()

        body := fmt.Sprintln("mainpage here.")

        records, err := r.storageService.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, errToStatus(err), err)
                return
        }</span>
        <span class="cov2" title="2">if len(records) &gt; 0 </span><span class="cov1" title="1">{
                body += fmt.Sprintln("metrics list:")

                for _, record := range records </span><span class="cov2" title="2">{
                        body += fmt.Sprintf("%s =&gt; %s: %v\n", record.Name, record.Value.Kind(), record.Value)
                }</span>
        }

        <span class="cov2" title="2">rw.Header().Set("Content-Type", "text/html")

        _, err = rw.Write([]byte(body))
        if err != nil </span><span class="cov0" title="0">{
                logging.LogErrorCtx(ctx, err)
        }</span>
}

// UpdateMetric godoc
// @Tags Metrics
// @Router /update/{type}/{name}/{value} [post]
// @Summary Push metric data.
// @ID metrics_update
// @Produce plain
// @Param type path string true "Metrics type (e.g. `counter`, `gauge`)."
// @Param name path string true "Metrics name."
// @Param value path string true "Metrics value, must be convertable to `int64` or `float64`."
// @Success 200 {string} string
// @Failure 400 {string} string http.StatusBadRequest
// @Failure 500 {string} string http.StatusInternalServerError
func (r MetricResource) UpdateMetric(rw http.ResponseWriter, req *http.Request) <span class="cov6" title="9">{
        ctx := req.Context()

        mex := metrics.MetricExchange{
                ID:    req.PathValue("metricName"),
                MType: req.PathValue("metricKind"),
        }

        rawValue := req.PathValue("metricValue")

        switch mex.MType </span>{
        case metrics.KindCounter:<span class="cov4" title="5">
                delta, err := metrics.ToCounter(rawValue)
                if err != nil </span><span class="cov1" title="1">{
                        writeErrorResponse(ctx, rw, errToStatus(err), err)
                        return
                }</span>

                <span class="cov4" title="4">mex.Delta = &amp;delta</span>
        case metrics.KindGauge:<span class="cov3" title="3">
                value, err := metrics.ToGauge(rawValue)
                if err != nil </span><span class="cov1" title="1">{
                        writeErrorResponse(ctx, rw, errToStatus(err), err)
                        return
                }</span>

                <span class="cov2" title="2">mex.Value = &amp;value</span>
        }

        <span class="cov5" title="7">record, err := toRecord(&amp;mex)
        if err != nil </span><span class="cov4" title="4">{
                writeErrorResponse(ctx, rw, errToStatus(err), err)
                return
        }</span>

        <span class="cov3" title="3">newRecord, err := r.storageService.Push(ctx, record)
        if err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov3" title="3">rw.WriteHeader(http.StatusOK)

        if _, err = io.WriteString(rw, newRecord.Value.String()); err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, http.StatusInternalServerError, err)
                return
        }</span>
}

// UpdateMetricJSON godoc
// @Tags Metrics
// @Router /update [post]
// @Summary Push metric data as JSON
// @ID metrics_json_update
// @Accept  json
// @Param request body metrics.MetricExchange true "Request parameters."
// @Success 200 {object} metrics.MetricExchange
// @Failure 400 {string} string http.StatusBadRequest
// @Failure 500 {string} string http.StatusInternalServerError
func (r MetricResource) UpdateMetricJSON(rw http.ResponseWriter, req *http.Request) <span class="cov5" title="6">{
        ctx := req.Context()

        mex := new(metrics.MetricExchange)
        if err := json.NewDecoder(req.Body).Decode(mex); err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        err = errors.New("no json provided")
                }</span>

                <span class="cov0" title="0">writeErrorResponse(ctx, rw, http.StatusBadRequest, err)
                return</span>
        }

        <span class="cov5" title="6">record, err := toRecord(mex)
        if err != nil </span><span class="cov3" title="3">{
                writeErrorResponse(ctx, rw, errToStatus(err), err)
                return
        }</span>

        <span class="cov3" title="3">newRecord, err := r.storageService.Push(ctx, record)
        if err != nil </span><span class="cov1" title="1">{
                writeErrorResponse(ctx, rw, http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov2" title="2">mex, err = toMetricExchange(newRecord)
        if err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov2" title="2">rw.Header().Set("Content-Type", "application/json")

        if err := json.NewEncoder(rw).Encode(mex); err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, http.StatusInternalServerError, err)
                return
        }</span>
}

// UpdateMetricsBatch godoc
// @Tags Metrics
// @Router /updates [post]
// @Summary Push list of metrics data as JSON
// @ID metrics_json_update_list
// @Accept  json
// @Param request body []metrics.MetricExchange true "List of metrics to update."
// @Success 200 {object} []metrics.MetricExchange
// @Failure 400 {string} string http.StatusBadRequest
// @Failure 500 {string} string http.StatusInternalServerError
func (r MetricResource) UpdateMetricsBatch(rw http.ResponseWriter, req *http.Request) <span class="cov5" title="6">{
        ctx := req.Context()

        records, err := parseJSONMetricsList(req)
        if err != nil </span><span class="cov4" title="4">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        err = errors.New("no json provided")
                }</span>

                <span class="cov4" title="4">writeErrorResponse(ctx, rw, http.StatusBadRequest, err)
                return</span>
        }

        <span class="cov2" title="2">recorded, err := r.storageService.PushList(ctx, records)
        if err != nil </span><span class="cov1" title="1">{
                writeErrorResponse(ctx, rw, http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov1" title="1">resp, err := toMetricExchangeList(recorded)
        if err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov1" title="1">rw.Header().Set("Content-Type", "application/json")

        if err := json.NewEncoder(rw).Encode(resp); err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov1" title="1">profiler.GetProfiler().SaveMemoryProfile()</span>
}

// GetMetric godoc
// @Tags Metrics
// @Router /value/{type}/{name} [get]
// @Summary Get metric's value as string
// @ID metrics_info
// @Produce plain
// @Param type path string true "Metrics type (e.g. `counter`, `gauge`)."
// @Param name path string true "Metrics name."
// @Success 200 {string} string
// @Failure 400 {string} string http.StatusBadRequest
// @Failure 404 {string} string http.StatusNotFound
// @Failure 500 {string} string http.StatusInternalServerError
func (r MetricResource) GetMetric(rw http.ResponseWriter, req *http.Request) <span class="cov4" title="5">{
        ctx := req.Context()

        metricName := req.PathValue("metricName")
        metricKind := req.PathValue("metricKind")

        if err := validators.ValidateMetric(metricName, metricKind); err != nil </span><span class="cov3" title="3">{
                writeErrorResponse(ctx, rw, errToStatus(err), err)
                return
        }</span>

        <span class="cov2" title="2">var record storage.Record
        record, err := r.storageService.Get(ctx, metricName, metricKind)
        if err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, errToStatus(err), err)
                return
        }</span>

        <span class="cov2" title="2">body := record.Value.String()

        rw.WriteHeader(http.StatusOK)

        _, err = rw.Write([]byte(body))
        if err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, http.StatusInternalServerError, err)
                return
        }</span>
}

// GetMetricJSON godoc
// @Tags Metrics
// @Router /value [post]
// @Summary Get metrics value as JSON
// @ID metrics_json_info
// @Accept  json
// @Produce json
// @Param request body metrics.MetricExchange true "Request parameters: `id` and `type` are required."
// @Success 200 {object} metrics.MetricExchange
// @Failure 400 {string} string http.StatusBadRequest
// @Failure 404 {string} string http.StatusNotFound
// @Failure 500 {string} string http.StatusInternalServerError
func (r MetricResource) GetMetricJSON(rw http.ResponseWriter, req *http.Request) <span class="cov6" title="8">{
        ctx := req.Context()

        mex := new(metrics.MetricExchange)
        if err := json.NewDecoder(req.Body).Decode(mex); err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov6" title="8">if err := validators.ValidateMetric(mex.ID, mex.MType); err != nil </span><span class="cov3" title="3">{
                writeErrorResponse(ctx, rw, errToStatus(err), err)
                return
        }</span>

        <span class="cov4" title="5">record, err := r.storageService.Get(ctx, mex.ID, mex.MType)
        if err != nil </span><span class="cov3" title="3">{
                writeErrorResponse(ctx, rw, errToStatus(err), err)
                return
        }</span>

        <span class="cov2" title="2">mex, err = toMetricExchange(record)
        if err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov2" title="2">rw.Header().Set("Content-Type", "application/json")

        if err := json.NewEncoder(rw).Encode(mex); err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(ctx, rw, http.StatusInternalServerError, err)
                return
        }</span>
}

func parseJSONMetricsList(r *http.Request) ([]storage.Record, error) <span class="cov5" title="6">{
        req := make([]metrics.MetricExchange, 0)
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="6">records := make([]storage.Record, len(req))

        for i := range req </span><span class="cov5" title="7">{
                record, err := toRecord(&amp;req[i])
                if err != nil </span><span class="cov3" title="3">{
                        return nil, err
                }</span>

                <span class="cov4" title="4">records[i] = record</span>
        }

        <span class="cov3" title="3">if len(records) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no metrics provided")
        }</span>

        <span class="cov2" title="2">return records, nil</span>
}

// Resource to handle ping requests
type PingerResource struct {
        pinger services.Pinger
}

// Constructor
func NewPingerResource(pinger services.Pinger) PingerResource <span class="cov10" title="40">{
        return PingerResource{
                pinger: pinger,
        }
}</span>

// Ping godoc
// @Tags Healthcheck
// @Router /ping [get]
// @Summary Verify server up and running
// @ID health_info
// @Success 200
// @Failure 500 {string} string http.StatusInternalServerError
// @Failure 501 {string} string http.StatusNotImplemented
func (pr PingerResource) Ping(w http.ResponseWriter, r *http.Request) <span class="cov3" title="3">{
        ctx := r.Context()

        err := pr.pinger.Ping(ctx)
        if err == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov2" title="2">if errors.Is(err, entities.ErrStorageUnpingable) </span><span class="cov1" title="1">{
                writeErrorResponse(ctx, w, http.StatusNotImplemented, err)
                return
        }</span>

        <span class="cov1" title="1">writeErrorResponse(ctx, w, http.StatusInternalServerError, err)</span>
}

func errToStatus(err error) int <span class="cov8" title="18">{
        switch err </span>{
        case entities.ErrRecordNotFound, entities.ErrMetricMissingName:<span class="cov3" title="3">
                return http.StatusNotFound</span>
        case
                entities.ErrMetricUnknown, entities.ErrMetricInvalidValue,
                entities.ErrMetricInvalidName, entities.ErrMetricLongName,
                entities.ErrMetricMissingValue:<span class="cov7" title="14">

                return http.StatusBadRequest</span>
        case entities.ErrUnexpected:<span class="cov1" title="1">
                return http.StatusInternalServerError</span>
        default:<span class="cov0" title="0">
                return http.StatusInternalServerError</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package httpserver implements REST API for metrics collector server.
package httpserver

// @Title Metrics collector API
// @Description Service for storing metrics data.
// @Version 1.0

// @Contact.name  Evgeniy Shuvalov
// @Contact.email evshuvalov@yandex.ru

// @Tag.name Metrics
// @Tag.description "Metrics API"

// @Tag.name Healthcheck
// @Tag.description "API to inspect service health state"

import (
        "net/http"

        _ "github.com/ex0rcist/metflix/docs/api"
        httpSwagger "github.com/swaggo/http-swagger"

        chimdlw "github.com/go-chi/chi/middleware"
        "github.com/go-chi/chi/v5"

        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/middleware"
        "github.com/ex0rcist/metflix/internal/services"
        "github.com/ex0rcist/metflix/internal/storage"
)

// Router constructor
func NewRouter(
        storageService storage.StorageService,
        pingerService services.Pinger,
        secret entities.Secret,
) http.Handler <span class="cov10" title="40">{
        router := chi.NewRouter()

        router.Use(chimdlw.RealIP)
        router.Use(chimdlw.StripSlashes)

        router.Use(middleware.RequestsLogger)

        router.Use(func(next http.Handler) http.Handler </span><span class="cov10" title="40">{
                return middleware.CheckSignedRequest(next, secret)
        }</span>)

        <span class="cov10" title="40">router.Use(middleware.DecompressRequest)
        router.Use(middleware.CompressResponse)

        router.Use(func(next http.Handler) http.Handler </span><span class="cov10" title="40">{
                return middleware.SignResponse(next, secret)
        }</span>)

        <span class="cov10" title="40">router.NotFound(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusNotFound) // no default body
        }</span>))

        <span class="cov10" title="40">router.Get("/swagger/*", httpSwagger.WrapHandler)

        registerMetricsEndpoints(storageService, router)
        registerPingerEndpoint(pingerService, router)

        return router</span>
}

func registerMetricsEndpoints(storageService storage.StorageService, router *chi.Mux) <span class="cov10" title="40">{
        resource := NewMetricResource(storageService)

        router.Get("/", resource.Homepage)

        router.Post("/update/{metricKind}/{metricName}/{metricValue}", resource.UpdateMetric)
        router.Post("/update", resource.UpdateMetricJSON)
        router.Post("/updates", resource.UpdateMetricsBatch)

        router.Get("/value/{metricKind}/{metricName}", resource.GetMetric)
        router.Post("/value", resource.GetMetricJSON)
}</span>

func registerPingerEndpoint(pingerService services.Pinger, router *chi.Mux) <span class="cov10" title="40">{
        resource := NewPingerResource(pingerService)

        router.Get("/ping", resource.Ping)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package httpserver

import (
        "context"
        "net/http"

        "github.com/ex0rcist/metflix/internal/entities"
)

// HTTP-server wrapper.
type Server struct {
        server *http.Server
        notify chan error
}

// Constructor.
func New(handler http.Handler, address entities.Address) *Server <span class="cov0" title="0">{
        httpServer := &amp;http.Server{
                Handler: handler,
                Addr:    address.String(),
        }

        s := &amp;Server{
                server: httpServer,
                notify: make(chan error, 1),
        }

        return s
}</span>

// Run server in a goroutine.
func (s *Server) Start() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                s.notify &lt;- s.server.ListenAndServe()
                close(s.notify)
        }</span>()
}

// Return channel to handle errors.
func (s *Server) Notify() &lt;-chan error <span class="cov0" title="0">{
        return s.notify
}</span>

// Shutdown server.
func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if s.server == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return s.server.Shutdown(ctx)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package logging

import (
        "context"
        "fmt"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

// Log with level=debug and formatting
func LogDebugF(format string, args ...any) <span class="cov0" title="0">{
        message := fmt.Sprintf(format, args...)
        logDebug(&amp;log.Logger, message)
}</span>

// Log with level=debug
func LogDebug(messages ...string) <span class="cov0" title="0">{
        logDebug(&amp;log.Logger, messages...)
}</span>

// Log with context (request_id) and level=debug
func LogDebugCtx(ctx context.Context, messages ...string) <span class="cov0" title="0">{
        logger := loggerFromContext(ctx)
        logDebug(logger, messages...)
}</span>

func logDebug(logger *zerolog.Logger, messages ...string) <span class="cov0" title="0">{
        msg := optMessagesToString(messages)
        logger.Debug().Msg(msg)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package logging

import (
        "context"
        "fmt"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

// Log with level=error and formatting
func LogErrorF(format string, err error) <span class="cov0" title="0">{
        fErr := fmt.Errorf(format, err)
        logError(&amp;log.Logger, fErr)
}</span>

// Log with level=error
func LogError(err error, messages ...string) <span class="cov0" title="0">{
        logError(&amp;log.Logger, err, messages...)
}</span>

// Log with context (request_id) and level=error
func LogErrorCtx(ctx context.Context, err error, messages ...string) <span class="cov0" title="0">{
        logger := loggerFromContext(ctx)
        logError(logger, err, messages...)
}</span>

func logError(logger *zerolog.Logger, err error, messages ...string) <span class="cov0" title="0">{
        msg := optMessagesToString(messages)

        if isDebugLevel() </span><span class="cov0" title="0">{
                logger.Error().Stack().Err(err).Msg(msg) // Stack() must be called before Err()
        }</span> else<span class="cov0" title="0"> {
                logger.Error().Err(err).Msg(msg)
        }</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package logging

import (
        "context"
        "fmt"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

// Log with level=fatal and formatting
func LogFatalF(format string, err error) <span class="cov0" title="0">{
        fErr := fmt.Errorf(format, err)
        logFatal(&amp;log.Logger, fErr)
}</span>

// Log with level=fatal
func LogFatal(err error, messages ...string) <span class="cov0" title="0">{
        logFatal(&amp;log.Logger, err, messages...)
}</span>

// Log with context (request_id) and level=fatal
func LogFatalCtx(ctx context.Context, err error, messages ...string) <span class="cov0" title="0">{
        logger := loggerFromContext(ctx)
        logFatal(logger, err, messages...)
}</span>

func logFatal(logger *zerolog.Logger, err error, messages ...string) <span class="cov0" title="0">{
        msg := optMessagesToString(messages)

        if isDebugLevel() </span><span class="cov0" title="0">{
                logger.Fatal().Stack().Err(err).Msg(msg) // Stack() must be called before Err()
        }</span> else<span class="cov0" title="0"> {
                logger.Fatal().Err(err).Msg(msg)
        }</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package logging

import (
        "context"
        "fmt"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

// Log with level=info and formatting
func LogInfoF(format string, args ...any) <span class="cov0" title="0">{
        message := fmt.Sprintf(format, args...)
        logInfo(&amp;log.Logger, message)
}</span>

// Log with level=info
func LogInfo(messages ...string) <span class="cov0" title="0">{
        logInfo(&amp;log.Logger, messages...)
}</span>

// Log with context (request_id) and level=info
func LogInfoCtx(ctx context.Context, messages ...string) <span class="cov0" title="0">{
        logger := loggerFromContext(ctx)
        logInfo(logger, messages...)
}</span>

func logInfo(logger *zerolog.Logger, messages ...string) <span class="cov0" title="0">{
        msg := optMessagesToString(messages)
        logger.Info().Msg(msg)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package logging

import (
        "context"
        "fmt"
        "io"
        "os"
        "strings"
        "time"

        "github.com/caarlos0/env/v11"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/rs/zerolog/pkgerrors"
)

type config struct {
        ENV string `env:"APP_ENV" envDefault:"development"`
}

// Initialize logging
func Setup() <span class="cov8" title="1">{
        cfg := parseConfig()

        var output io.Writer
        var logger zerolog.Logger

        switch cfg.ENV </span>{
        case "tracing":<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.TraceLevel)
                zerolog.ErrorStackMarshaler = pkgerrors.MarshalStack

                output = zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339Nano}</span>
        case "development":<span class="cov8" title="1">
                zerolog.SetGlobalLevel(zerolog.DebugLevel)

                output = zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339Nano}</span>
        case "production":<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)

                output = os.Stdout</span>
        }

        <span class="cov8" title="1">loggerCtx := zerolog.New(output).With().Timestamp()
        switch </span>{
        case isTraceLevel():<span class="cov0" title="0">
                logger = loggerCtx.Caller().Logger()</span>
        default:<span class="cov8" title="1">
                logger = loggerCtx.Logger()</span>
        }

        <span class="cov8" title="1">log.Logger = logger
        zerolog.DefaultContextLogger = &amp;logger</span>
}

func parseConfig() config <span class="cov8" title="1">{
        cfg := config{}
        if err := env.Parse(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%+v\n", err)
        }</span>

        <span class="cov8" title="1">return cfg</span>
}

func optMessagesToString(messages []string) string <span class="cov0" title="0">{
        if len(messages) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // remove empty
        <span class="cov0" title="0">var result []string
        for _, str := range messages </span><span class="cov0" title="0">{
                if str != "" </span><span class="cov0" title="0">{
                        result = append(result, str)
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(result, "; ")</span>
}

func loggerFromContext(ctx context.Context) *zerolog.Logger <span class="cov0" title="0">{
        return zerolog.Ctx(ctx)
}</span>

func isDebugLevel() bool <span class="cov0" title="0">{
        return zerolog.GlobalLevel() == zerolog.DebugLevel
}</span>

func isTraceLevel() bool <span class="cov8" title="1">{
        return zerolog.GlobalLevel() == zerolog.TraceLevel
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package logging

import (
        "context"
        "fmt"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

// Log with level=warn and formatting
func LogWarnF(format string, args ...any) <span class="cov0" title="0">{
        message := fmt.Sprintf(format, args...)
        logWarn(&amp;log.Logger, message)
}</span>

// Log with level=warn
func LogWarn(messages ...string) <span class="cov0" title="0">{
        logWarn(&amp;log.Logger, messages...)
}</span>

// Log with context (request_id) and level=warn
func LogWarnCtx(ctx context.Context, messages ...string) <span class="cov0" title="0">{
        logger := loggerFromContext(ctx)
        logWarn(logger, messages...)
}</span>

func logWarn(logger *zerolog.Logger, messages ...string) <span class="cov0" title="0">{
        msg := optMessagesToString(messages)
        logger.Warn().Msg(msg)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package middleware

import (
        "errors"
        "net/http"
        "strings"

        "github.com/ex0rcist/metflix/internal/compression"
        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/logging"
)

// Decompress request if possible
func DecompressRequest(next http.Handler) http.Handler <span class="cov10" title="4">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="4">{
                ctx := r.Context()

                encoding := r.Header.Get("Content-Encoding")
                if len(encoding) == 0 </span><span class="cov1" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov8" title="3">decompressor := compression.NewDecompressor(r, ctx)
                defer decompressor.Close()

                err := decompressor.Decompress()
                if err != nil </span><span class="cov5" title="2">{
                        switch </span>{
                        case errors.Is(err, entities.ErrEncodingUnsupported):<span class="cov1" title="1">
                                http.Error(w, err.Error(), http.StatusBadRequest)
                                return</span>
                        case errors.Is(err, entities.ErrEncodingInternal):<span class="cov1" title="1">
                                http.Error(w, "", http.StatusInternalServerError)
                                return</span>
                        }
                }

                <span class="cov1" title="1">next.ServeHTTP(w, r)</span>
        })
}

// Compress response if needed
func CompressResponse(next http.Handler) http.Handler <span class="cov5" title="2">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov5" title="2">{
                ctx := r.Context()

                if !needGzipEncoding(r) </span><span class="cov1" title="1">{
                        logging.LogDebugCtx(ctx, "compression not requested or not supported by client")

                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov1" title="1">compressor := compression.NewCompressor(w, ctx)
                defer compressor.Close()

                next.ServeHTTP(compressor, r)</span>
        })
}

func needGzipEncoding(r *http.Request) bool <span class="cov10" title="4">{
        if len(r.Header.Get("Accept-Encoding")) == 0 </span><span class="cov5" title="2">{
                return false
        }</span>

        <span class="cov5" title="2">for _, encoding := range r.Header.Values("Accept-Encoding") </span><span class="cov5" title="2">{
                if strings.Contains(encoding, "gzip") </span><span class="cov5" title="2">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package middleware

import (
        "net/http"
        "time"

        "github.com/ex0rcist/metflix/internal/utils"
        "github.com/go-chi/chi/middleware"
        "github.com/rs/zerolog/log"
)

// Log requests middleware
func RequestsLogger(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                requestID := findOrCreateRequestID(r)

                // setup child logger for middleware
                logger := log.Logger.With().
                        Str("rid", requestID).
                        Logger()

                // log started
                logger.Info().
                        Str("method", r.Method).
                        Str("url", r.URL.String()).
                        Str("remote-addr", r.RemoteAddr). // middleware.RealIP
                        Msg("Started")

                logger.Debug().
                        Msgf("request: %s", utils.HeadersToStr(r.Header))

                // execute
                ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)
                ctx := logger.WithContext(r.Context())
                next.ServeHTTP(ww, r.WithContext(ctx))

                logger.Debug().
                        Msgf("response: %s", utils.HeadersToStr(ww.Header()))

                // log completed
                logger.Info().
                        Float64("elapsed", time.Since(start).Seconds()).
                        Int("status", ww.Status()).
                        Int("size", ww.BytesWritten()).
                        Msg("Completed")
        }</span>)
}

func findOrCreateRequestID(r *http.Request) string <span class="cov10" title="2">{
        requestID := r.Header.Get("X-Request-Id")

        if requestID == "" </span><span class="cov1" title="1">{
                requestID = utils.GenerateRequestID()
        }</span>

        <span class="cov10" title="2">return requestID</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package middleware

import (
        "bytes"
        "fmt"
        "io"
        "net/http"

        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/internal/services"
        "github.com/go-chi/chi/middleware"
)

// CustomResponseWriter is a wrapper around http.ResponseWriter that captures the response body
type CustomResponseWriter struct {
        http.ResponseWriter
        body *bytes.Buffer
}

// Write body
func (w *CustomResponseWriter) Write(b []byte) (int, error) <span class="cov1" title="1">{
        return w.body.Write(b)
}</span>

// Sign response middleware
func SignResponse(next http.Handler, secret entities.Secret) http.Handler <span class="cov6" title="2">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov6" title="2">{
                ctx := r.Context()

                if len(secret) == 0 </span><span class="cov1" title="1">{ // skip middleware entirely
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // wrap the ResponseWriter with chi's middleware.WrapResponseWriter
                <span class="cov1" title="1">ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                // create a buffer to capture the response body
                bodyBuffer := &amp;bytes.Buffer{}

                // create a custom ResponseWriter to capture the response body
                crw := &amp;CustomResponseWriter{ResponseWriter: ww, body: bodyBuffer}

                // pass the custom ResponseWriter to the next handler
                next.ServeHTTP(crw, r)

                signer := services.NewSignerService(secret)
                signature, _ := signer.CalculateSignature(bodyBuffer.Bytes())

                w.Header().Set("HashSHA256", signature)

                // write the captured body to the original ResponseWriter
                _, err := w.Write(bodyBuffer.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        logging.LogErrorCtx(ctx, fmt.Errorf("got empty signature for request"))
                        return
                }</span>
        })
}

// Ensure incoming request satisfies it's signature.
func CheckSignedRequest(next http.Handler, secret entities.Secret) http.Handler <span class="cov10" title="3">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="3">{
                ctx := r.Context()

                if len(secret) == 0 </span><span class="cov1" title="1">{ // skip middleware entirely
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov6" title="2">protected := map[string]struct{}{"POST": {}, "PUT": {}, "PATCH": {}}
                if _, ok := protected[r.Method]; !ok </span><span class="cov0" title="0">{
                        logging.LogDebugCtx(ctx, "no need to check sign for that method")
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov6" title="2">hash := r.Header.Get("HashSHA256")
                if len(hash) == 0 </span><span class="cov0" title="0">{
                        // just pass it through for backward compatibility
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov6" title="2">bodyBytes, err := io.ReadAll(r.Body)
                defer func() </span><span class="cov6" title="2">{
                        if closeErr := r.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                logging.LogError(closeErr)
                        }</span>
                }()

                <span class="cov6" title="2">if err != nil </span><span class="cov0" title="0">{
                        logging.LogErrorCtx(ctx, fmt.Errorf("failed to read request body"))
                        http.Error(w, "failed to read request body", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov6" title="2">signer := services.NewSignerService(secret)
                ok, _ := signer.VerifySignature(bodyBytes, hash)
                if !ok </span><span class="cov1" title="1">{
                        logging.LogErrorCtx(ctx, fmt.Errorf("failed to verify request signature"))
                        http.Error(w, "Failed to verify signature", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov1" title="1">logging.LogDebugCtx(ctx, "got correct signature")

                r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package profiler

import (
        "fmt"
        "os"
        "runtime"
        "runtime/pprof"
        "sync"
        "sync/atomic"
        "time"

        "github.com/ex0rcist/metflix/internal/logging"
)

var (
        profilerInstance *Profiler
        once             sync.Once
)

// Profiler service obj to make snapshots
type Profiler struct {
        callCounter int32
}

// Singleton
func GetProfiler() *Profiler <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                profilerInstance = &amp;Profiler{}
        }</span>)
        <span class="cov8" title="1">return profilerInstance</span>
}

// Save snapshot. Count is a special case to take snapshot in similar conditions.
func (p *Profiler) SaveMemoryProfile() <span class="cov8" title="1">{
        count := atomic.AddInt32(&amp;p.callCounter, 1)

        if count != 3 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">timestamp := time.Now().Format("20060102-150405")
        fileName := fmt.Sprintf("./memory_profile_%s.prof", timestamp)

        f, err := os.Create(fileName)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logging.LogError(err)
                }</span>
        }()

        <span class="cov0" title="0">runtime.GC()
        if err := pprof.WriteHeapProfile(f); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">fmt.Printf("Memory profile saved as %s\n", fileName)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package retrier

import (
        "time"

        "github.com/avast/retry-go"
        "github.com/ex0rcist/metflix/internal/logging"
)

// Retrier option to configure retrier
type RetryOption func(*Retrier)

// Retrier service to make some retries
type Retrier struct {
        payloadFn retry.RetryableFunc
        retryIfFn retry.RetryIfFunc
        delays    []time.Duration
}

// Run, Forest
func (r Retrier) Run() error <span class="cov8" title="3">{
        return retry.Do(
                r.payloadFn,
                retry.RetryIf(r.retryIfFn),
                retry.DelayType(func(n uint, err error, config *retry.Config) time.Duration </span><span class="cov10" title="4">{
                        logging.LogWarnF("will retry after %v", r.delays[n])
                        return r.delays[n]
                }</span>),
                retry.Attempts(uint(len(r.delays))+1),
        )
}

// RetryOption to add delays setting
func WithDelays(delays []time.Duration) RetryOption <span class="cov8" title="3">{
        return func(r *Retrier) </span><span class="cov8" title="3">{
                r.delays = delays
        }</span>
}

// Constructor
func New(payloadFn func() error, retryIfFn func(err error) bool, opts ...RetryOption) *Retrier <span class="cov8" title="3">{
        r := &amp;Retrier{
                payloadFn: payloadFn,
                retryIfFn: retryIfFn,
        }

        for _, opt := range opts </span><span class="cov8" title="3">{
                opt(r)
        }</span>

        <span class="cov8" title="3">return r</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package server

import (
        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/httpserver"
        "github.com/go-chi/chi"
        "github.com/go-chi/chi/middleware"
)

// Profiler server to serve pprof
type ProfilerServer struct {
        *httpserver.Server
}

// Profiler server constructor
func NewProfilerServer(address entities.Address) *ProfilerServer <span class="cov10" title="2">{
        r := chi.NewRouter()

        r.Use(middleware.Logger)
        r.Mount("/debug", middleware.Profiler())

        server := httpserver.New(r, address)

        prf := &amp;ProfilerServer{server}

        return prf
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/caarlos0/env/v11"
        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/httpserver"
        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/internal/services"
        "github.com/ex0rcist/metflix/internal/storage"
        "github.com/spf13/pflag"
)

const shutdownTimeout = 60 * time.Second

// Backend heart
type Server struct {
        config     *Config
        httpServer *httpserver.Server
        profiler   *ProfilerServer
        storage    storage.MetricsStorage
        router     http.Handler
}

// Backend config
type Config struct {
        Address         entities.Address `env:"ADDRESS"`
        StoreInterval   int              `env:"STORE_INTERVAL"`
        StorePath       string           `env:"FILE_STORAGE_PATH"`
        RestoreOnStart  bool             `env:"RESTORE"`
        DatabaseDSN     string           `env:"DATABASE_DSN"`
        Secret          entities.Secret  `env:"KEY"`
        ProfilerAddress entities.Address `env:"PROFILER_ADDRESS"`
}

// Server constructor
func New() (*Server, error) <span class="cov5" title="2">{
        config := &amp;Config{
                Address:         "0.0.0.0:8080",
                StoreInterval:   300,
                RestoreOnStart:  true,
                ProfilerAddress: "0.0.0.0:8081",
        }

        err := parseConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">dataStorage, err := newDataStorage(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">storageService := storage.NewService(dataStorage)
        pingerService := services.NewPingerService(dataStorage)
        router := httpserver.NewRouter(storageService, pingerService, config.Secret)

        httpServer := httpserver.New(router, config.Address)
        pprofiler := NewProfilerServer(config.ProfilerAddress)

        return &amp;Server{
                config:     config,
                httpServer: httpServer,
                storage:    dataStorage,
                router:     router,
                profiler:   pprofiler,
        }, nil</span>
}

// Start all subservices
func (s *Server) Start() <span class="cov0" title="0">{
        interrupt := make(chan os.Signal, 1)
        signal.Notify(interrupt, os.Interrupt, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)

        s.httpServer.Start()
        s.profiler.Start()

        logging.LogInfo(s.String())
        logging.LogInfo("server ready")

        select </span>{
        case s := &lt;-interrupt:<span class="cov0" title="0">
                logging.LogInfo("interrupt: signal " + s.String())</span>
        case err := &lt;-s.httpServer.Notify():<span class="cov0" title="0">
                logging.LogError(err, "Server -&gt; Start() -&gt; s.httpServer.Notify")</span>
        case err := &lt;-s.profiler.Notify():<span class="cov0" title="0">
                logging.LogError(err, "Server -&gt; Start() - s.profiler.Notify")</span>
        }

        <span class="cov0" title="0">logging.LogInfo("shutting down...")

        stopped := make(chan struct{})
        stopCtx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()

        go func() </span><span class="cov0" title="0">{
                s.shutdown(stopCtx)
                close(stopped)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-stopped:<span class="cov0" title="0">
                logging.LogInfo("server shutdown successful")</span>

        case &lt;-stopCtx.Done():<span class="cov0" title="0">
                logging.LogInfo("shutdown timeout exceeded")</span>
        }
}

// Stringer for logging
func (s *Server) String() string <span class="cov1" title="1">{
        kind := detectStorageKind(s.config)

        str := []string{
                fmt.Sprintf("address=%s", s.config.Address),
                fmt.Sprintf("storage=%s", kind),
        }

        if kind == storage.KindFile </span><span class="cov0" title="0">{
                str = append(str, fmt.Sprintf("store-interval=%d", s.config.StoreInterval))
                str = append(str, fmt.Sprintf("store-path=%s", s.config.StorePath))
                str = append(str, fmt.Sprintf("restore=%t", s.config.RestoreOnStart))
        }</span>

        <span class="cov1" title="1">if kind == storage.KindDatabase </span><span class="cov0" title="0">{
                str = append(str, fmt.Sprintf("database=%s", s.config.DatabaseDSN))
        }</span>

        <span class="cov1" title="1">if len(s.config.Secret) &gt; 0 </span><span class="cov0" title="0">{
                str = append(str, fmt.Sprintf("secret=%s", s.config.Secret))
        }</span>

        <span class="cov1" title="1">return "server config: " + strings.Join(str, "; ")</span>
}

func (s *Server) shutdown(ctx context.Context) <span class="cov0" title="0">{
        logging.LogInfo("shutting down HTTP API")
        if err := s.httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logging.LogError(err)
        }</span>

        <span class="cov0" title="0">logging.LogInfo("shutting down storage")
        if err := s.storage.Close(ctx); err != nil </span><span class="cov0" title="0">{
                logging.LogError(err)
        }</span>

        <span class="cov0" title="0">logging.LogInfo("shutting down profiler")
        if err := s.profiler.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logging.LogError(err)
        }</span>
}

func parseConfig(config *Config) error <span class="cov5" title="2">{
        err := parseFlags(config, os.Args[0], os.Args[1:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="2">err = parseEnv(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="2">return nil</span>
}

func parseFlags(config *Config, progname string, args []string) error <span class="cov10" title="4">{
        flags := pflag.NewFlagSet(progname, pflag.ContinueOnError)

        address := config.Address
        flags.VarP(&amp;address, "address", "a", "address:port for HTTP API requests")

        secret := config.Secret
        flags.VarP(&amp;secret, "secret", "k", "a key to sign outgoing data")

        // define flags
        flags.IntVarP(&amp;config.StoreInterval, "store-interval", "i", config.StoreInterval, "interval (s) for dumping metrics to the disk, zero value means saving after each request")
        flags.StringVarP(&amp;config.StorePath, "store-file", "f", config.StorePath, "path to file to store metrics")
        flags.BoolVarP(&amp;config.RestoreOnStart, "restore", "r", config.RestoreOnStart, "whether to restore state on startup")
        flags.StringVarP(&amp;config.DatabaseDSN, "database", "d", config.DatabaseDSN, "PostgreSQL database DSN")

        err := flags.Parse(args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // fill values
        <span class="cov10" title="4">flags.Visit(func(f *pflag.Flag) </span><span class="cov5" title="2">{
                switch f.Name </span>{
                case "address":<span class="cov5" title="2">
                        config.Address = address</span>
                case "secret":<span class="cov0" title="0">
                        config.Secret = secret</span>
                }
        })

        <span class="cov10" title="4">return nil</span>
}

func parseEnv(config *Config) error <span class="cov5" title="2">{
        if err := env.Parse(config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="2">return nil</span>
}

func detectStorageKind(c *Config) string <span class="cov8" title="3">{
        var sk string

        switch </span>{
        case c.DatabaseDSN != "":<span class="cov0" title="0">
                sk = storage.KindDatabase</span>
        case c.StorePath != "":<span class="cov0" title="0">
                sk = storage.KindFile</span>
        default:<span class="cov8" title="3">
                sk = storage.KindMemory</span>
        }

        <span class="cov8" title="3">return sk</span>
}

func newDataStorage(config *Config) (storage.MetricsStorage, error) <span class="cov5" title="2">{
        storageKind := detectStorageKind(config)

        switch storageKind </span>{
        case storage.KindMemory:<span class="cov5" title="2">
                return storage.NewMemStorage(), nil</span>
        case storage.KindFile:<span class="cov0" title="0">
                return storage.NewFileStorage(config.StorePath, config.StoreInterval, config.RestoreOnStart)</span>
        case storage.KindDatabase:<span class="cov0" title="0">
                return storage.NewPostgresStorage(config.DatabaseDSN)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown storage type")</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/storage"
)

var _ Pinger = PingerService{}

// Pinger interface
type Pinger interface {
        Ping(ctx context.Context) error
}

// Pinger service to make healthcheck
type PingerService struct {
        storage storage.MetricsStorage
}

// Pinger constructor.
func NewPingerService(storage storage.MetricsStorage) PingerService <span class="cov10" title="3">{
        return PingerService{storage: storage}
}</span>

// Ping-pong.
func (s PingerService) Ping(ctx context.Context) error <span class="cov10" title="3">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        strg, ok := s.storage.(Pinger)
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("storage ping failed: %w", entities.ErrStorageUnpingable)
        }</span>

        <span class="cov6" title="2">if err := strg.Ping(ctx); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("storage check failed: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package services

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"

        "github.com/ex0rcist/metflix/internal/entities"
)

var _ Signer = SignerService{}

// Interface to Signer service
type Signer interface {
        CalculateSignature(data []byte) (string, error)
        VerifySignature(data []byte, hash string) (bool, error)
}

// Signer service
type SignerService struct {
        secret []byte
}

// Signer constructor
func NewSignerService(secret entities.Secret) SignerService <span class="cov10" title="3">{
        return SignerService{secret: []byte(secret)}
}</span>

// Calculate signature of []byte
func (s SignerService) CalculateSignature(data []byte) (string, error) <span class="cov10" title="3">{
        mac := hmac.New(sha256.New, s.secret)

        _, err := mac.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="3">digest := mac.Sum(nil)

        return hex.EncodeToString(digest), nil</span>
}

// Verify signature, provided for []byte.
func (s SignerService) VerifySignature(data []byte, hash string) (bool, error) <span class="cov6" title="2">{
        if len(hash) == 0 </span><span class="cov0" title="0">{
                return false, entities.ErrNoSignature
        }</span>

        <span class="cov6" title="2">expected, err := s.CalculateSignature(data)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov6" title="2">return expected == hash, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package storage

import (
        "context"
        "errors"
        "fmt"

        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/pkg/metrics"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

var _ MetricsStorage = PostgresStorage{}

// PostgresStorage
type PostgresStorage struct {
        Pool PGXPool
}

type dbQueryTracer struct {
        logger *zerolog.Logger
}

// Logs query
func (tracer *dbQueryTracer) TraceQueryStart(ctx context.Context, _ *pgx.Conn, data pgx.TraceQueryStartData) context.Context <span class="cov0" title="0">{
        tracer.logger.Debug().Msg(fmt.Sprintf("Executing command \"%s\" with args %v", data.SQL, data.Args))
        return ctx
}</span>

// Does nothing, required by interface
func (tracer *dbQueryTracer) TraceQueryEnd(ctx context.Context, conn *pgx.Conn, data pgx.TraceQueryEndData) {<span class="cov0" title="0">
        // empty
}</span>

// DatabseStorage constructor
func NewPostgresStorage(dsn string) (*PostgresStorage, error) <span class="cov0" title="0">{
        migrator := NewDatabaseMigrator(dsn, "file://db/migrate", 5)

        if err := migrator.Run(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("migrations run failed: %w", err)
        }</span>

        <span class="cov0" title="0">config, err := pgxpool.ParseConfig(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pgxpool parsse config failed: %w", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        config.ConnConfig.Tracer = &amp;dbQueryTracer{logger: &amp;log.Logger}

        pool, err := pgxpool.NewWithConfig(ctx, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pgxpool init failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;PostgresStorage{Pool: pool}, nil</span>
}

// Push record to storage
func (d PostgresStorage) Push(ctx context.Context, key string, record Record) error <span class="cov1" title="1">{
        tx, err := d.Pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db storage Push() -&gt; Begin() error: %w", err)
        }</span>

        <span class="cov1" title="1">sql := "INSERT INTO metrics(id, name, kind, value) values ($1, $2, $3, $4) ON CONFLICT (id) DO UPDATE SET value = $4"
        _, err = tx.Exec(ctx, sql, key, record.Name, record.Value.Kind(), record.Value.String())
        if err != nil </span><span class="cov0" title="0">{
                rErr := tx.Rollback(ctx)
                if rErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("db storage Push() -&gt; Rollback() error: %w", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("db storage Push() -&gt; Exec() error: %w", err)</span>
        }

        <span class="cov1" title="1">return tx.Commit(ctx)</span>
}

// Push list of records to storage
func (d PostgresStorage) PushList(ctx context.Context, data map[string]Record) error <span class="cov1" title="1">{
        batch := new(pgx.Batch)
        sql := "INSERT INTO metrics(id, name, kind, value) values ($1, $2, $3, $4) ON CONFLICT (id) DO UPDATE SET value = $4"
        for id, record := range data </span><span class="cov10" title="2">{
                batch.Queue(sql, id, record.Name, record.Value.Kind(), record.Value.String())
        }</span>

        <span class="cov1" title="1">batchResp := d.Pool.SendBatch(ctx, batch)
        defer func() </span><span class="cov1" title="1">{
                if err := batchResp.Close(); err != nil </span><span class="cov0" title="0">{
                        logging.LogErrorCtx(ctx, err, "failed to close batchResp")
                }</span>
        }()

        <span class="cov1" title="1">for i := 0; i &lt; len(data); i++ </span><span class="cov10" title="2">{
                if _, err := batchResp.Exec(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("db storage PushBatch() Exec error: %w", err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// Get a record from storage
func (d PostgresStorage) Get(ctx context.Context, key string) (Record, error) <span class="cov1" title="1">{
        var (
                name   string
                kind   string
                value  float64
                record Record
                err    error
        )

        sql := "SELECT name, kind, value FROM metrics WHERE id=$1"
        err = d.Pool.QueryRow(ctx, sql, string(key)).Scan(&amp;name, &amp;kind, &amp;value)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return Record{}, entities.ErrRecordNotFound
                }</span>

                <span class="cov0" title="0">return record, fmt.Errorf("db storage Get() error: %w", err)</span>
        }

        <span class="cov1" title="1">switch kind </span>{
        case metrics.KindCounter:<span class="cov1" title="1">
                record, err = Record{Name: name, Value: metrics.Counter(value)}, nil</span>
        case metrics.KindGauge:<span class="cov0" title="0">
                record, err = Record{Name: name, Value: metrics.Gauge(value)}, nil</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("db storage kind=%s unknown", kind)</span>
        }

        <span class="cov1" title="1">return record, err</span>
}

// Get list of records from storage
func (d PostgresStorage) List(ctx context.Context) ([]Record, error) <span class="cov1" title="1">{
        rows, err := d.Pool.Query(ctx, "SELECT name, kind, value FROM metrics")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("db storage List() error: %w", err)
        }</span>

        <span class="cov1" title="1">if rowErr := rows.Err(); rowErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("db storage List() error: %w", rowErr)
        }</span>

        <span class="cov1" title="1">defer rows.Close()

        var (
                name  string
                kind  string
                value float64
        )

        result := make([]Record, 0)
        _, err = pgx.ForEachRow(rows, []any{&amp;name, &amp;kind, &amp;value}, func() error </span><span class="cov10" title="2">{
                switch kind </span>{
                case metrics.KindCounter:<span class="cov1" title="1">
                        result = append(result, Record{Name: name, Value: metrics.Counter(value)})
                        return nil</span>

                case metrics.KindGauge:<span class="cov1" title="1">
                        result = append(result, Record{Name: name, Value: metrics.Gauge(value)})
                        return nil</span>

                default:<span class="cov0" title="0">
                        return fmt.Errorf("db storage kind=%s unknown", kind)</span>
                }
        })

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("db storage List() error: %w", err)
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// Healthcheck
func (d PostgresStorage) Ping(ctx context.Context) error <span class="cov1" title="1">{
        if err := d.Pool.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db storage Ping() error: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Close storage pool
func (d PostgresStorage) Close(ctx context.Context) error <span class="cov1" title="1">{
        d.Pool.Close()
        return nil
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package storage

import (
        "errors"
        "time"

        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/internal/retrier"

        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

// Service to migrate database
type DatabaseMigrator struct {
        dsn     string
        retries int
        source  string

        migrator *migrate.Migrate
        err      error
}

// DatabaseMigrator Constructor
func NewDatabaseMigrator(dsn string, source string, retries int) DatabaseMigrator <span class="cov0" title="0">{
        return DatabaseMigrator{dsn: dsn, source: source, retries: retries}
}</span>

// Run migrations if any (with retries)
func (m DatabaseMigrator) Run() error <span class="cov0" title="0">{
        delays := []time.Duration{1 * time.Second, 3 * time.Second, 5 * time.Second}

        m.err = retrier.New(
                func() error </span><span class="cov0" title="0">{
                        logging.LogInfo("migrations: connecting to " + m.dsn)

                        migrator, err := migrate.New(m.source, m.dsn)
                        m.migrator = migrator

                        if err != nil </span><span class="cov0" title="0">{
                                logging.LogError(err)
                        }</span>

                        <span class="cov0" title="0">return err</span>
                },
                func(err error) bool <span class="cov0" title="0">{
                        return true
                }</span>,
                retrier.WithDelays(delays),
        ).Run()

        <span class="cov0" title="0">if m.err != nil </span><span class="cov0" title="0">{
                return m.err
        }</span>

        <span class="cov0" title="0">m.err = m.migrator.Up()

        defer func() </span><span class="cov0" title="0">{
                srcErr, dbErr := m.migrator.Close()

                if srcErr != nil </span><span class="cov0" title="0">{
                        logging.LogError(srcErr, "failed closing migrator", srcErr.Error())
                }</span>

                <span class="cov0" title="0">if dbErr != nil </span><span class="cov0" title="0">{
                        logging.LogError(dbErr, "failed closing migrator", dbErr.Error())
                }</span>
        }()

        <span class="cov0" title="0">if m.err == nil </span><span class="cov0" title="0">{
                logging.LogInfo("migrations: success")
                return nil
        }</span>

        <span class="cov0" title="0">if errors.Is(m.err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                logging.LogInfo("migrations: no change")
                return nil
        }</span>

        <span class="cov0" title="0">return m.err</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package storage

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "sync"
        "time"

        "github.com/ex0rcist/metflix/internal/logging"
        "github.com/ex0rcist/metflix/internal/utils"
)

var _ MetricsStorage = (*FileStorage)(nil)

// File-backed storage.
type FileStorage struct {
        *MemStorage
        sync.Mutex

        storePath      string
        storeInterval  int
        restoreOnStart bool
        dumpTicker     *time.Ticker
}

// FileStorage constructor.
func NewFileStorage(storePath string, storeInterval int, restoreOnStart bool) (*FileStorage, error) <span class="cov10" title="5">{
        fs := &amp;FileStorage{
                MemStorage:     NewMemStorage(),
                storePath:      storePath,
                storeInterval:  storeInterval,
                restoreOnStart: restoreOnStart,
        }

        if fs.restoreOnStart </span><span class="cov1" title="1">{
                if err := fs.restore(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov10" title="5">if fs.storeInterval &gt; 0 </span><span class="cov1" title="1">{
                fs.dumpTicker = time.NewTicker(utils.IntToDuration(fs.storeInterval))
                go fs.startStorageDumping(fs.dumpTicker)
        }</span>

        <span class="cov10" title="5">return fs, nil</span>
}

// Push a record to the storage.
func (s *FileStorage) Push(ctx context.Context, id string, record Record) error <span class="cov7" title="3">{
        if err := s.MemStorage.Push(ctx, id, record); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="3">if s.storeInterval == 0 </span><span class="cov4" title="2">{
                return s.dump()
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Push list of records to the storage.
func (s *FileStorage) PushList(ctx context.Context, data map[string]Record) error <span class="cov0" title="0">{
        if err := s.MemStorage.PushList(ctx, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if s.storeInterval == 0 </span><span class="cov0" title="0">{
                return s.dump()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Close storage (dump to disk)
func (s *FileStorage) Close(_ context.Context) error <span class="cov1" title="1">{
        if s.dumpTicker != nil </span><span class="cov1" title="1">{
                s.dumpTicker.Stop()
        }</span>

        <span class="cov1" title="1">return s.dump()</span>
}

func (s *FileStorage) dump() (err error) <span class="cov8" title="4">{
        logging.LogInfo("dumping storage to file " + s.storePath)

        s.Lock()
        defer s.Unlock()

        file, err := os.OpenFile(s.storePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error during FileStorage.Dump()/os.OpenFile(): %w", err)
        }</span>

        <span class="cov8" title="4">defer func() </span><span class="cov8" title="4">{
                if closeErr := file.Close(); err == nil &amp;&amp; closeErr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error during FileStorage.Dump()/file.Close(): %w", closeErr)
                }</span>
        }()

        <span class="cov8" title="4">encoder := json.NewEncoder(file)
        snapshot := s.Snapshot()

        if err := encoder.Encode(snapshot); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error during FileStorage.Dump()/encoder.Encode(): %w", err)
        }</span>

        <span class="cov8" title="4">return nil</span>
}

func (s *FileStorage) restore() (err error) <span class="cov1" title="1">{
        logging.LogInfo("restoring storage from file " + s.storePath)

        s.Lock()
        defer s.Unlock()

        file, err := os.Open(s.storePath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        logging.LogWarn("no storage dump found to restore")
                        return nil
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("error during FileStorage.Restore()/os.Open(): %w", err)</span>
        }

        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if closeErr := file.Close(); err == nil &amp;&amp; closeErr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error during FileStorage.Restore()/file.Close(): %w", closeErr)
                }</span>
        }()

        <span class="cov1" title="1">decoder := json.NewDecoder(file)
        if err := decoder.Decode(s.MemStorage); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error during FileStorage.Restore()/decoder.Decode(): %w", err)
        }</span>

        <span class="cov1" title="1">logging.LogInfo("storage data was restored")

        return nil</span>
}

func (s *FileStorage) startStorageDumping(ticker *time.Ticker) <span class="cov1" title="1">{
        defer ticker.Stop()

        for </span><span class="cov4" title="2">{
                _, ok := &lt;-ticker.C
                if !ok </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov1" title="1">if err := s.dump(); err != nil </span><span class="cov0" title="0">{
                        logging.LogError(fmt.Errorf("error during FileStorage Dump(): %s", err.Error()))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package storage

import (
        "context"
        "sync"

        "github.com/ex0rcist/metflix/internal/entities"
)

var _ MetricsStorage = (*MemStorage)(nil)

// In-memory storage.
type MemStorage struct {
        sync.Mutex
        Data map[string]Record `json:"records"`
}

// MemoryStorage constructor.
func NewMemStorage() *MemStorage <span class="cov10" title="11">{
        return &amp;MemStorage{
                Data: make(map[string]Record),
        }
}</span>

// Push a record to the storage.
func (s *MemStorage) Push(_ context.Context, id string, record Record) error <span class="cov9" title="10">{
        s.Lock()
        defer s.Unlock()

        s.Data[id] = record

        return nil
}</span>

// Push list of records to the storage.
func (s *MemStorage) PushList(_ context.Context, data map[string]Record) error <span class="cov1" title="1">{
        s.Lock()
        defer s.Unlock()

        for id, record := range data </span><span class="cov3" title="2">{
                s.Data[id] = record
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Get single record from the storage.
func (s *MemStorage) Get(_ context.Context, id string) (Record, error) <span class="cov10" title="11">{
        s.Lock()
        defer s.Unlock()

        record, ok := s.Data[id]
        if !ok </span><span class="cov1" title="1">{
                return Record{}, entities.ErrRecordNotFound
        }</span>

        <span class="cov9" title="10">return record, nil</span>
}

// Get list of records from the storage.
func (s *MemStorage) List(_ context.Context) ([]Record, error) <span class="cov1" title="1">{
        s.Lock()
        defer s.Unlock()

        arr := make([]Record, len(s.Data))

        i := 0
        for _, record := range s.Data </span><span class="cov3" title="2">{
                arr[i] = record
                i++
        }</span>

        <span class="cov1" title="1">return arr, nil</span>
}

// Take snapshot of records.
func (s *MemStorage) Snapshot() *MemStorage <span class="cov6" title="4">{
        s.Lock()
        defer s.Unlock()

        snapshot := make(map[string]Record, len(s.Data))

        for k, v := range s.Data </span><span class="cov6" title="4">{
                snapshot[k] = v
        }</span>

        <span class="cov6" title="4">return &amp;MemStorage{Data: snapshot}</span>
}

// Close storage (does nothing for in-memory).
func (s *MemStorage) Close(_ context.Context) error <span class="cov0" title="0">{
        return nil // do nothing
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package storage

import (
        "encoding/json"
        "fmt"

        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/pkg/metrics"
)

// Struct to store metrics in storage
type Record struct {
        Name  string
        Value metrics.Metric
}

// Calculate record ID for ease of store and search
func CalculateRecordID(name, kind string) string <span class="cov10" title="44">{
        if len(name) == 0 || len(kind) == 0 </span><span class="cov4" title="5">{
                return ""
        }</span>

        <span class="cov9" title="39">return name + "_" + kind</span>
}

// Calculate record ID for ease of store and search
func (r Record) CalculateRecordID() string <span class="cov9" title="38">{
        return CalculateRecordID(r.Name, r.Value.Kind())
}</span>

// Serialize to JSON
func (r Record) MarshalJSON() ([]byte, error) <span class="cov5" title="6">{
        jv, err := json.Marshal(map[string]string{
                "name":  r.Name,
                "kind":  r.Value.Kind(),
                "value": r.Value.String(),
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("record marshaling fail: %w", err)
        }</span>

        <span class="cov5" title="6">return jv, nil</span>
}

// Deserialize from JSON
func (r *Record) UnmarshalJSON(src []byte) error <span class="cov6" title="9">{
        var data map[string]string

        if err := json.Unmarshal(src, &amp;data); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("record unmarshaling failed: %w", err)
        }</span>

        <span class="cov5" title="8">r.Name = data["name"]

        switch data["kind"] </span>{
        case metrics.KindCounter:<span class="cov4" title="5">
                value, err := metrics.ToCounter(data["value"])
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("record unmarshaling failed: %w", err)
                }</span>

                <span class="cov4" title="4">r.Value = value</span>
        case metrics.KindGauge:<span class="cov2" title="2">
                value, err := metrics.ToGauge(data["value"])
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("record unmarshaling failed: %w", err)
                }</span>

                <span class="cov1" title="1">r.Value = value</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("record unmarshaling failed: %w", entities.ErrMetricUnknown)</span>
        }

        <span class="cov4" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package storage

import (
        "context"
        "errors"
        "fmt"
        "sort"

        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/pkg/metrics"
)

// Common interface for service layer. Storage service prepares data before calling storage
type StorageService interface {
        List(ctx context.Context) ([]Record, error)
        Push(ctx context.Context, record Record) (Record, error)
        PushList(ctx context.Context, records []Record) ([]Record, error)
        Get(ctx context.Context, name, kind string) (Record, error)
}

var _ StorageService = Service{}

// Service struct, containing storage
type Service struct {
        Storage MetricsStorage
}

// Service constructor
func NewService(storage MetricsStorage) Service <span class="cov10" title="17">{
        return Service{Storage: storage}
}</span>

// Get record from bound storage.
func (s Service) Get(ctx context.Context, name, kind string) (Record, error) <span class="cov3" title="2">{
        id := CalculateRecordID(name, kind)

        record, err := s.Storage.Get(ctx, id)
        if err != nil </span><span class="cov1" title="1">{
                return Record{}, err
        }</span>

        <span class="cov1" title="1">return record, nil</span>
}

// Push record to bound storage.
func (s Service) Push(ctx context.Context, record Record) (Record, error) <span class="cov7" title="7">{
        newValue, err := s.calculateNewValue(ctx, record)
        if err != nil </span><span class="cov3" title="2">{
                return Record{}, err
        }</span>

        <span class="cov6" title="5">record.Value = newValue
        err = s.Storage.Push(ctx, record.CalculateRecordID(), record)

        if err != nil </span><span class="cov1" title="1">{
                return Record{}, err
        }</span>

        <span class="cov5" title="4">return record, nil</span>
}

// Push list of records to bound storage
func (s Service) PushList(ctx context.Context, records []Record) ([]Record, error) <span class="cov1" title="1">{
        data := make(map[string]Record)

        for _, record := range records </span><span class="cov4" title="3">{
                id := record.CalculateRecordID()

                if prev, ok := data[id]; ok </span><span class="cov0" title="0">{
                        if record.Value.Kind() == metrics.KindCounter </span><span class="cov0" title="0">{
                                record.Value = prev.Value.(metrics.Counter) + record.Value.(metrics.Counter)
                        }</span>

                        <span class="cov0" title="0">data[id] = record

                        continue</span>
                }

                <span class="cov4" title="3">newValue, err := s.calculateNewValue(ctx, record)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to calculate new value: %w", err)
                }</span>

                <span class="cov4" title="3">record.Value = newValue
                data[id] = record</span>
        }

        <span class="cov1" title="1">if err := s.Storage.PushList(ctx, data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to PushList(): %w", err)
        }</span>

        <span class="cov1" title="1">result := make([]Record, 0, len(data))
        for _, v := range data </span><span class="cov4" title="3">{
                result = append(result, v)
        }</span>

        <span class="cov1" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov4" title="3">{
                return result[i].Name &lt; result[j].Name
        }</span>)

        <span class="cov1" title="1">return result, nil</span>
}

// List records from bound storage
func (s Service) List(ctx context.Context) ([]Record, error) <span class="cov3" title="2">{
        records, err := s.Storage.List(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">sort.Slice(records, func(i, j int) bool </span><span class="cov1" title="1">{
                return records[i].Name &lt; records[j].Name
        }</span>)

        <span class="cov1" title="1">return records, nil</span>
}

func (s Service) calculateNewValue(ctx context.Context, record Record) (metrics.Metric, error) <span class="cov9" title="15">{
        if record.Value.Kind() != metrics.KindCounter </span><span class="cov6" title="6">{
                return record.Value, nil
        }</span>

        <span class="cov7" title="9">id := record.CalculateRecordID()
        if id == "" </span><span class="cov1" title="1">{
                return record.Value, entities.ErrMetricMissingName
        }</span>

        <span class="cov7" title="8">storedRecord, err := s.Storage.Get(ctx, id)
        if errors.Is(err, entities.ErrRecordNotFound) </span><span class="cov4" title="3">{
                return record.Value, nil
        }</span> else<span class="cov6" title="5"> if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="3">return storedRecord.Value.(metrics.Counter) + record.Value.(metrics.Counter), nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package utils

import (
        "fmt"
        "net/http"
        "sort"
        "strings"
)

// Compose headers to string (for logging)
func HeadersToStr(headers http.Header) string <span class="cov8" title="4">{
        stringsSlice := []string{}

        for name, values := range headers </span><span class="cov8" title="4">{
                for _, value := range values </span><span class="cov10" title="5">{
                        stringsSlice = append(stringsSlice, fmt.Sprintf("%s:%s", name, value))
                }</span>
        }

        <span class="cov8" title="4">sort.Slice(stringsSlice, func(i, j int) bool </span><span class="cov4" title="2">{
                return stringsSlice[i] &lt; stringsSlice[j]
        }</span>)

        <span class="cov8" title="4">return strings.Join(stringsSlice, ", ")</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package utils

import (
        uuid "github.com/satori/go.uuid"
)

// Generate unique request id
func GenerateRequestID() string <span class="cov8" title="1">{
        return uuid.NewV4().String()
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package utils

import "time"

// Convert int (seconds) to time.Duration
func IntToDuration(s int) time.Duration <span class="cov10" title="5">{
        return time.Duration(s) * time.Second
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package validators

import (
        "regexp"

        "github.com/ex0rcist/metflix/internal/entities"
        "github.com/ex0rcist/metflix/pkg/metrics"
)

var nameRegexp = regexp.MustCompile(`^[A-Za-z\d]+$`)

// Ensure metric is valid
func ValidateMetric(name, kind string) error <span class="cov10" title="7">{
        if err := validateMetricName(name); err != nil </span><span class="cov7" title="4">{
                return err
        }</span>

        <span class="cov6" title="3">if err := validateMetricKind(kind); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func validateMetricName(name string) error <span class="cov10" title="7">{
        if len(name) == 0 </span><span class="cov4" title="2">{
                return entities.ErrMetricMissingName
        }</span>

        <span class="cov8" title="5">if !nameRegexp.MatchString(name) </span><span class="cov4" title="2">{
                return entities.ErrMetricInvalidName
        }</span>

        <span class="cov6" title="3">return nil</span>
}

func validateMetricKind(kind string) error <span class="cov6" title="3">{
        switch kind </span>{
        case metrics.KindCounter, metrics.KindGauge:<span class="cov4" title="2">
                return nil</span>

        default:<span class="cov1" title="1">
                return entities.ErrMetricUnknown</span>
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
        "context"

        "github.com/go-openapi/strfmt"
        "github.com/go-openapi/swag"
)

// MetricsMetricExchange metrics metric exchange
//
// swagger:model metrics.MetricExchange
type MetricsMetricExchange struct {

        // delta
        Delta int64 `json:"delta,omitempty"`

        // id
        ID string `json:"id,omitempty"`

        // type
        Type string `json:"type,omitempty"`

        // value
        Value float64 `json:"value,omitempty"`
}

// Validate validates this metrics metric exchange
func (m *MetricsMetricExchange) Validate(formats strfmt.Registry) error <span class="cov0" title="0">{
        return nil
}</span>

// ContextValidate validates this metrics metric exchange based on context it is used
func (m *MetricsMetricExchange) ContextValidate(ctx context.Context, formats strfmt.Registry) error <span class="cov0" title="0">{
        return nil
}</span>

// MarshalBinary interface implementation
func (m *MetricsMetricExchange) MarshalBinary() ([]byte, error) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return swag.WriteJSON(m)</span>
}

// UnmarshalBinary interface implementation
func (m *MetricsMetricExchange) UnmarshalBinary(b []byte) error <span class="cov0" title="0">{
        var res MetricsMetricExchange
        if err := swag.ReadJSON(b, &amp;res); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*m = res
        return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Package metrics provides client REST API for metrics collector (server).
package metrics

// Create new MetricExchange struct with metrics.Counter value to be used for updating metrics.
func NewUpdateCounterMex(name string, value Counter) MetricExchange <span class="cov0" title="0">{
        return MetricExchange{ID: name, MType: value.Kind(), Delta: &amp;value}
}</span>

// Create new MetricExchange struct with metrics.Gauge value to be used for updating metrics.
func NewUpdateGaugeMex(name string, value Gauge) MetricExchange <span class="cov0" title="0">{
        return MetricExchange{ID: name, MType: value.Kind(), Value: &amp;value}
}</span>

// Create new MetMetricExchange struct to be used for retrieving of counter metric.
func NewGetCounterMex(name string) MetricExchange <span class="cov0" title="0">{
        return MetricExchange{ID: name, MType: KindCounter}
}</span>

// Create new MetMetricExchange struct to be used for retrieving of gauge metric.
func NewGetGaugeMex(name string) MetricExchange <span class="cov0" title="0">{
        return MetricExchange{ID: name, MType: KindGauge}
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package metrics

import (
        "strconv"

        "github.com/ex0rcist/metflix/internal/entities"
)

// Available metric types.
const (
        KindCounter = "counter"
        KindGauge   = "gauge"
)

// Metric interface
type Metric interface {
        Kind() string
        String() string
}

// Gauge metric type - int64.
type Counter int64

// Return metric kind
func (c Counter) Kind() string <span class="cov1" title="1">{
        return KindCounter
}</span>

// Stringer
func (c Counter) String() string <span class="cov1" title="1">{
        return strconv.FormatInt(int64(c), 10)
}</span>

// Gauge metric type - float64.
type Gauge float64

// Return metric kind
func (g Gauge) Kind() string <span class="cov1" title="1">{
        return KindGauge
}</span>

// Stringer
func (g Gauge) String() string <span class="cov10" title="2">{
        return strconv.FormatFloat(float64(g), 'f', -1, 64)
}</span>

// Convert string value to metrics.Counter
func ToCounter(value string) (Counter, error) <span class="cov0" title="0">{
        rawValue, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, entities.ErrMetricInvalidValue
        }</span>

        <span class="cov0" title="0">return Counter(rawValue), nil</span>
}

// Convert string value to metrics.Gauge
func ToGauge(value string) (Gauge, error) <span class="cov0" title="0">{
        rawValue, err := strconv.ParseFloat(value, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, entities.ErrMetricInvalidValue
        }</span>

        <span class="cov0" title="0">return Gauge(rawValue), nil</span>
}

// Agent/Server exchange schema according to spec
type MetricExchange struct {
        ID    string   `json:"id"`
        MType string   `json:"type"`
        Delta *Counter `json:"delta,omitempty"`
        Value *Gauge   `json:"value,omitempty"`
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package noexit implement static analyzer which checks
// for use of 'os.Exit' in the main function of main package.
package noexit

import (
        "go/ast"
        "strings"

        "golang.org/x/tools/go/analysis"
)

// Initialize analysis.Analyzer
var Analyzer = &amp;analysis.Analyzer{
        Name: "noexit",
        Doc:  "forbids usage of os.Exit in the main function of main package",
        Run:  run,
}

// isMainFunc returns true if the specified node declares 'func main'.
func isMainFunc(node *ast.FuncDecl) bool <span class="cov4" title="7">{
        if node.Name == nil || node.Name.Obj == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="7">decl := node.Name.Obj

        return decl.Kind == ast.Fun &amp;&amp; decl.Name == "main"</span>
}

func validateCallExpr(node ast.Node, pass *analysis.Pass) <span class="cov4" title="12">{
        call, ok := node.(*ast.CallExpr)
        if !ok </span><span class="cov2" title="2">{
                return
        }</span>

        <span class="cov4" title="10">selector, ok := call.Fun.(*ast.SelectorExpr)
        if !ok </span><span class="cov2" title="2">{
                return
        }</span>

        <span class="cov4" title="8">var pkgName string
        if pkg, ok := selector.X.(*ast.Ident); ok </span><span class="cov4" title="8">{
                pkgName = pkg.Name
        }</span>

        <span class="cov4" title="8">if pkgName == "os" &amp;&amp; selector.Sel.Name == "Exit" </span><span class="cov4" title="7">{
                pass.Reportf(node.Pos(), "os.Exit in main function is forbidden")
                return
        }</span>
}

func validateExprStmt(node *ast.ExprStmt, pass *analysis.Pass) <span class="cov4" title="7">{
        validateCallExpr(node.X, pass)
}</span>

func validateGoStmt(node *ast.GoStmt, pass *analysis.Pass) <span class="cov1" title="1">{
        if node.Call != nil </span><span class="cov1" title="1">{
                validateCallExpr(node.Call, pass)
        }</span>
}

func validateDeferStmt(node *ast.DeferStmt, pass *analysis.Pass) <span class="cov3" title="4">{
        if node.Call != nil </span><span class="cov3" title="4">{
                validateCallExpr(node.Call, pass)
        }</span>
}

func run(pass *analysis.Pass) (interface{}, error) <span class="cov4" title="10">{
        for _, file := range pass.Files </span><span class="cov4" title="9">{
                // Ignore test and not-.go files like ~/Library/Caches/go-build/...
                filename := pass.Fset.Position(file.Pos()).Filename
                if strings.HasSuffix(filename, "_test.go") || !strings.HasSuffix(filename, ".go") </span><span class="cov2" title="2">{
                        continue</span>
                }

                <span class="cov4" title="7">if file.Name != nil &amp;&amp; file.Name.Name != "main" </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov3" title="6">ast.Inspect(file, func(node ast.Node) bool </span><span class="cov10" title="334">{
                        switch x := node.(type) </span>{
                        case *ast.FuncDecl:<span class="cov4" title="7">
                                return isMainFunc(x)</span>

                        case *ast.ExprStmt:<span class="cov4" title="7">
                                validateExprStmt(x, pass)</span>

                        case *ast.GoStmt:<span class="cov1" title="1">
                                validateGoStmt(x, pass)</span>

                        case *ast.DeferStmt:<span class="cov3" title="4">
                                validateDeferStmt(x, pass)</span>

                        case *ast.FuncLit:<span class="cov1" title="1">
                                return false</span>
                        }

                        <span class="cov9" title="326">return true</span>
                })
        }

        <span class="cov4" title="10">return nil, nil</span> //nolint: nilnil
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package staticlint implements multichecker static analyser with different linters.
// This package uses golang.org/x/tools/go/analysis/multichecker to combine different linters
//
// Staticlint includes:
//
// From golang.org/x/tools/go/analysis/passes:
// asmdecl, assign, atomic, atomicalign, bools, composite, copylock, deepequalerrors,
// directive, errorsas, httpresponse, ifaceassert, loopclosure, lostcancel,
// nilfunc, nilness, reflectvaluecompare, shadow, shift, sigchanyzer, sortslice,
// stdmethods, stringintconv, structtag, tests, timeformat, unmarshal,
// unreachable, unsafeptr, unusedresult, unusedwrite.
//
// See docs: https://pkg.go.dev/golang.org/x/tools/go/analysis/passes
//
// From staticheck.io:
//   - All SA* (staticcheck) linters.
//   - All S* (simple) linters.
//   - All ST* (stylecheck) linters.
//   - All QF* (quickfix) linters.
//
// See docs: https://staticcheck.io/docs/checks/
//
// Other publicly available linters:
//   - errcheck to check for unchecked errors in Go code, see
//     https://github.com/kisielk/errcheck
//   - bodyclose to check whether HTTP response body is closed and
//     a re-use of TCP connection is not blocked, see:
//     https://github.com/timakin/bodyclose
//   - rowserr to ensure whether pgx.Rows.err value is checked, see
//     https://github.com/jingyugao/rowserrcheck
//
// Custom linters:
//   - noexit to check whether os.Exit is not used in the main function of the main package.
package staticlint

import (
        "github.com/ex0rcist/metflix/pkg/noexit"
        "github.com/jingyugao/rowserrcheck/passes/rowserr"
        "github.com/kisielk/errcheck/errcheck"
        "github.com/timakin/bodyclose/passes/bodyclose"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/asmdecl"
        "golang.org/x/tools/go/analysis/passes/assign"
        "golang.org/x/tools/go/analysis/passes/atomic"
        "golang.org/x/tools/go/analysis/passes/atomicalign"
        "golang.org/x/tools/go/analysis/passes/bools"
        "golang.org/x/tools/go/analysis/passes/buildtag"
        "golang.org/x/tools/go/analysis/passes/composite"
        "golang.org/x/tools/go/analysis/passes/copylock"
        "golang.org/x/tools/go/analysis/passes/deepequalerrors"
        "golang.org/x/tools/go/analysis/passes/directive"
        "golang.org/x/tools/go/analysis/passes/errorsas"
        "golang.org/x/tools/go/analysis/passes/httpresponse"
        "golang.org/x/tools/go/analysis/passes/ifaceassert"
        "golang.org/x/tools/go/analysis/passes/loopclosure"
        "golang.org/x/tools/go/analysis/passes/lostcancel"
        "golang.org/x/tools/go/analysis/passes/nilfunc"
        "golang.org/x/tools/go/analysis/passes/nilness"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/reflectvaluecompare"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/shift"
        "golang.org/x/tools/go/analysis/passes/sigchanyzer"
        "golang.org/x/tools/go/analysis/passes/sortslice"
        "golang.org/x/tools/go/analysis/passes/stdmethods"
        "golang.org/x/tools/go/analysis/passes/stringintconv"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "golang.org/x/tools/go/analysis/passes/tests"
        "golang.org/x/tools/go/analysis/passes/timeformat"
        "golang.org/x/tools/go/analysis/passes/unmarshal"
        "golang.org/x/tools/go/analysis/passes/unreachable"
        "golang.org/x/tools/go/analysis/passes/unsafeptr"
        "golang.org/x/tools/go/analysis/passes/unusedresult"
        "golang.org/x/tools/go/analysis/passes/unusedwrite"
        "honnef.co/go/tools/analysis/lint"
        "honnef.co/go/tools/quickfix"
        "honnef.co/go/tools/simple"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/stylecheck"
)

// StaticLint is a structure to collect linters passed to multichecker
type StaticLint struct {
        checkers []*analysis.Analyzer
}

// Excluded chacks taken from Yandex-practicum static lint.
var excludedChecks = map[string]struct{}{
        // Incorrect or missing package comment
        "ST1000": {},
        // The documentation of an exported function should start with the function's name
        "ST1020": {},
        // The documentation of an exported type should start with type's name
        "ST1021": {},
        // The documentation of an exported variable or constant should start with variable's name
        "ST1022": {},
}

// Constructor.
func New() StaticLint <span class="cov0" title="0">{
        // Add analyzers from passes.
        checkers := []*analysis.Analyzer{
                asmdecl.Analyzer,
                assign.Analyzer,
                atomic.Analyzer,
                atomicalign.Analyzer,
                bools.Analyzer,
                buildtag.Analyzer,
                composite.Analyzer,
                copylock.Analyzer,
                deepequalerrors.Analyzer,
                directive.Analyzer,
                errorsas.Analyzer,
                httpresponse.Analyzer,
                ifaceassert.Analyzer,
                loopclosure.Analyzer,
                lostcancel.Analyzer,
                nilfunc.Analyzer,
                nilness.Analyzer,
                printf.Analyzer,
                reflectvaluecompare.Analyzer,
                shadow.Analyzer,
                shift.Analyzer,
                sigchanyzer.Analyzer,
                sortslice.Analyzer,
                stdmethods.Analyzer,
                stringintconv.Analyzer,
                structtag.Analyzer,
                tests.Analyzer,
                timeformat.Analyzer,
                unmarshal.Analyzer,
                unreachable.Analyzer,
                unsafeptr.Analyzer,
                unusedresult.Analyzer,
                unusedwrite.Analyzer,
        }

        // Add staticcheck analyzers.
        for _, collection := range [][]*lint.Analyzer{
                staticcheck.Analyzers,
                simple.Analyzers,
                stylecheck.Analyzers,
                quickfix.Analyzers,
        } </span><span class="cov0" title="0">{
                for _, v := range collection </span><span class="cov0" title="0">{
                        if _, exclude := excludedChecks[v.Analyzer.Name]; exclude </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">checkers = append(checkers, v.Analyzer)</span>
                }
        }

        // Add standalone analyzers.
        <span class="cov0" title="0">checkers = append(checkers, errcheck.Analyzer)
        checkers = append(checkers, bodyclose.Analyzer)
        checkers = append(checkers, rowserr.NewAnalyzer("github.com/jackc/pgx/v5"))

        // Add custom linter.
        checkers = append(checkers, noexit.Analyzer)

        return StaticLint{checkers}</span>
}

// Run linting.
func (s StaticLint) Run() <span class="cov0" title="0">{
        multichecker.Main(s.checkers...)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
